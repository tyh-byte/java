java概述
面向过程：（Pascal,C）关心过程，都是以什么正在发生为主要目标进行编程。面向过程是分析解决问题所需的步骤，然后使用函数逐步实现这些步骤。模块化思想。如公共汽车，面向过程关心的是汽车启动、汽车到站这些事件，而面对对象是关心汽车这个对象做了什么。到了编程就是
public class 汽车运营
{
	void 汽车启动{发生了什么} 
	void汽车到站（发生了什么）
}

面向对象：c++,c#,java,是一种理解和抽象显示世界的方法，由面向过程发展而来。对象的建立不是为了完成一个步骤，而是为了描述一个事务在解决问题的整个过程中的行为（抽象的）
public class 汽车
{
	void 到站（）{}
	void 启动（）{}
	
}

标准模板程序库是C++标准程序库的子集，包含容器、算法、迭代器、函数对象等。也有些人使用术语STL代表C++标准程序库。
使用C++标准程序库时，不必加上“.h”

快捷键
shift+f2  在网页中查该类的详细信息
f3  查该类的.class文件
ctrl+z  修复代码
ctrl+shift+f  格式化
ctrl+t  类层次
alt+/   代码提示
ctrl+k 查找相同的字段
ctrl+shift+b  断点
ctrl+o  显示大纲
shift+enter 新一行
alt+enter 当前.java文件的属性
1.1.1.4
       java ME SE EE  嵌入式应用 桌面应用 企业级应用
   .2
     特点：跨平台
           完全面向对象和简单性：不支持全局变量和宏替换，不支持goto语句，不支持指针类型，不支持结构类型，不支持头文件，内存动态存储且自动管理
           可靠性、安全性、多线程、支持分布式网络应用
   .3
     java核心技术：JDBC，JSP(动态网页技术标准)、JavaBean（对象组件技术）、JavaMail(提供E-mail邮件服务支持类库) 
   .4
     application应用：两种形式：application(控制台，用户界面) 和 applet（可嵌入web的最小应用）
1.2
   .1
   JDK:Integrated Development Environment,IDE
   jar:java archieve :java归档
   jdb：java调试器
   javac.exe java编译器
   java.exe java解释器
   src：source
   jre：java运行时环境
  
   javac *.java  编译文件
   java *.java   运行文件
   
   .2
   环境变量：path 指出可执行文件路径
             classpath 指出java包的路径

   .3
    包：类的集合，一个包中包含多个类，从存储方式看，包是类的组织方式，一个包就是一个文件夹，一个文件夹中 包含多个字节码文件
     .2
	java API 常用包  api （application programming interface,应用程序接口）
     .3
        引用包中的类包{.子包}.类|接口 [] 可重复0~1，{}可重复0~多
     .6
        导入包
        import 包{.子包}.类|接口|*；
         importy语句必须写在类声明之前 
     .7
        声明类所在包：package 包{.子包}
        package在源程序文件中只能写一次，且必须写在程序的第一行，即写在类声明之前，多
个类可以属于一个包
        没有main()方法则不能运行
     .9
       package--声明包，0~1句
       import---导入包，0~多
       public class或interface--声明公有类或接口 0~1，文件名与该名相同
       class---声明默认类 0~多
       interface--声明接口 0~多
 声明包的语句只能有一个，并且是第一条语句。声明为public的类或接口只能有一个，且文件名必须与该类名相同
     .10
        包可以压缩成JAR文件，JDK提供的文件压缩命令是jar.exe


1.3.1
     refactor 重构  navigate  导航
     在编辑器中，当类名或对象名后输入“.”时，自动出现代码提示窗口，按住ctrl键并单击类名或方法名时，可查看该方法声明
     常用视图；
              navigator:显示项目中的文件列表
              package explorer:显示项目中的包和文件
              outline：显示编辑器中的当前文件的方法声明，单击方法名可快速定位到指定方法
              hierarchy:显示当前类的继承关系
              problems：像是编译错误和警告信息
              console：显示控制台程序的运行结果
              tasks:显示代码中未完成的任务 
              debug:显示调试信息
              variables:显示调试过程的变量值    
    项目和工作区：workspace==》多个project==》java文件  .java
    通用功能的类，声明为public，可被其他应用程序引用
1.3.2
    创建项目-创建类
    创建java项目并运行
    可右键创建package-class  
    创建类可选择包含的方法  public static void main(string[] args)
    编辑、编译和运行
      执行主菜单edit下的（undo redo cut copy....）
      file下的open file save save as ....
      默认即时编译  project-build automatically,problems视图将同步显示编译错误
                 执行run  运行结果显示在console视图中
    重构
         refactor-rename可更改当前项目名或类名
     切换工作区
          file swith workspace  可选择另一个文件夹作为工作区
     导入项目
          file-import-general
     设置注释行
           source-toggle comment  toggle(触发器，开关)
     设置项目属性
           设置运行属性  run-run configurations-选中项目-设置运行的类、命令行参数等
                 一个项目可包含多个带有main()方法的类，可如上法设置运行的类（设置启动窗体）
                 在arguments的program arguments 编辑框中可输入命令行参数
           配制编译路径
                 右键-build path-configure build path-projeccts-add,配置后，访问其他类的权限就如同在当前包中
           添加JAR包
                在项目属性对话框的libraries上，单击add external jars  在jar selection 选择.jar文件
     设置环境属性
           window-preference  更新JDK、修改编辑区的字体和颜色、设置默认字符集等
                              更新JDK   -java-installed JREs-add- standard VM-next-directory
			      修改编辑区的字体和颜色：general-appearance-colors and fonts-basic-text font
                              设置默认字符集   general-workspace  默认GBK

1.3.3
     程序调试技术
        语法错（syntax error） 又编译错 标识符未声明、表达式中运算符与操作数类型不匹配、赋值时变量类型不兼容、括号不匹配、赋值时变量类型与表达式类型不兼容、括号不匹配、语句末缺少分号、else没有if
         语义错（semantic error） 又运行错 输入数据格式错，除数为0、变量赋值超出其范围、数组下标越界，一旦错误，将停止程序运行，在console视图中给出异常类和出错位置
         逻辑错（logical error） 如因循环条件错误导致没有运算结果、结果错误、或死循环等，运行系统对逻辑错没有识别能力
     .2
       程序运行方式：正常运行、单步运行、分段运行
       正常运行：run-run 直至程序结束，遇到运行错时，将终止运行，给出错误信息
       单步运行：step into:当运行到函数调用语句时，跟踪进入函数体内，对函数体进行单步调试
                 step over：将函数调用作为一条语句，一次执行完，不会跟踪进入函数体内
                 step return: 一次执行完函数体余下的语句序列，并返回到函数调用语句 
       分段运行：
　　　　　　　　run to line:运行至光标所在行
                resume：运行至下一个断点，将程序中的某一行语句设置为断点，当程序运行至断点时自动暂停。设置多个断点，把整个程序分成若干段
      .3
       调试过程
         设置断点：将光标设置在指定行，在行左边区域执行快捷菜单命令：toggle breakpoint 再次执行该命令，清除断点           
         调试界面：run-debug 到第一个断点暂停，执行window-show view 下的debug 和variable命令，打开相应视图，variables视图显示当前作用域内的变量值
          单步或分段运行：run-run to line  到光标  run-resume  到下一个断点暂停  run-terminate 停止调试，返回编辑状态，设置的断点依然有效
	  查看变量的当前值：variables视图显示的信息为当前作用域的变量值，自动改变
          附录 有照        


2 java语言基础
2.1.1 标识符与关键字
      toString 类名首字母大写，常量名全部字母均大写
2.1.2 基本数据类型
      两大类:基本数据类型（primitive）（8种、不可分解）和引用数据类型（reference types）（数组、类、接口）
      99l表示long型
      0123表示8进制 0x表示16进制
      unicode表示：\u0000~\uFFFF 如\u0041表示‘A’  \转义字符
2.1.3 变量与常量
       变量4要素：名字 类型 值 作用域
       最终变量 final 只能进行一次赋值
      
       常量：直接常量和符号常量
             直接常量；包括数值型和非数值型常量。
             符号常量保存在程序中不能被改变的数据，用关键字final声明  eg：final int MAX=100
2.1.4 运算符与表达式
       有字符串连接运算符“+”和instanceof，没有sizeof
       对象运算符  instanceof 判断一个对象是否属于指定类或其子类，运算结果是布尔类型
       左结合-操作数在运算符的左边  右结合-操作数在运算符的右边 从右边算
       布尔类型不是整数，true和false不能转换成数值1或0
       赋值相容：具有方向性，是不对称关系

2.2  流程控制语句
     顺序结构语句（赋值、空）、选择语句（if switch）、循环语句(while do-while for)、转移语句(break continue return)
     结构特点划分：简单语句、构造语句
2.2.1
    {}括起来的为块，是一条复合语句，其中变量的作用域仅限于该块
2.2.2
     if(bool表达式)    if while等语句中的条件表达式不能是赋值运算  如不可以是if(i=0)
         语句1；
     【else
          语句2；】
     
	//格式1?? ??? ?
?? ??? ?
	if(比较表达式){
?? ??? ??? ?
		语句体;
?? ??? ?
	}
?? ??? ?

	//格式2
?? ??? ?
	if(比较表达式){
?? ??? ??? ?
		语句体1;
?? ??? ?
	}else{
?? ??? ??? ?
		语句体2;
?? ??? ?
	}
?? ??? ?

	//格式3
?   分段函数? ??? ?
	if(比较表达式1){
? ? ? ? ? ? 
		语句体1;
?? ??? ?
	}
	else if(比较表达式2){
? ? ? ? ? ? 
		语句体2;
?? ??? ?
	}else if(比较表达式3){
? ? ? ? ? ? 
		语句体3;
?? ??? ?
	}
?? ??? ?
		...
?? ??? ?
	else{
?? ??? ??? ?
		语句体n+1
?? ??? ?
	}
如果 if 条件成立时的执行语句只有一条，是可以省略大括号滴！但如果执行语句有多条，那么大括号就是不可或缺的喽~~


     switch（表达式）
      {
         case 常量表达式1：语句序列1；[break;]
         case 常量表达式1：语句序列1；[break;]
          …………
         [default:语句序列;]
       }
2.2.3
    while(bool表达式)
          语句；

    do
    {
       语句；
     }while(布尔表达式)；

     for(表达式1;表达式2;表达式3)   此处无分号；
        语句；

2.2.4  循环体中无条件退出是一种很不好的习惯，不能作为程序设计的主流思想（break continue）

2.3  数组
   java的数组都是动态数组，用new运算符申请数组的存储空间
   声明方法：数据类型[]  数组变量  int[] a; int a[],i=0;i是int型变量
             数据类型  数组变量[]  inta[];  int[] a,i ；i是int[]变量
    使用new申请数组所需内存单元
     数组变量 =new 数据类型[长度]
     a=new int[5];声明时也可以申请：int a[]=new int[5];
     数组长度  数组变量.length
      各数据类型初值：引用：null  boolean:false  float：0.0f char:'\u0000'
     for语句作用于数组的逐元循环    获得数组中的每个元素
    for(类型 变量：数组)  for(int value:fib) system.out.print(""+value)
      数组的引用模型  b=a；b引用a拥有的数组，之后改变b同时a也会改变。 a==b为true ，复制a的话为false
2.3.2  二维数组
      int mat[][];
      mat=new int[4][5]; ==>int mat[][]=new int[4][5];
      mat.length  //返回二维数组长度，即行数
      mat[0].length //返回一维数组长度，即二维数组的列数
    不规则的二维数组
      int mat[][]=new int[3][] ;
      mat[0]=new int[3];
      mat[1]=new int[4];
      

2.4  静态方法
	静态方法是用来操作这个类型的，方法被该类的所有实例共享。
	而实例方法用来操作单个实例，不被该类所有实例共享。
	静态方法中不能调用实例方法，也不能访问实例变量。
	实例方法可以调用静态方法，也能访问静态变量。
	总之静态方法对应的是类型，即Class，类。但是实例方法对应的是实例，即object，对象
    java语言没有全局函数，函数声明在勒种，称为成员方法，有静态方法和实例方法两种
     方法声明与调用 
      声明格式：【修饰符】 返回值类型 方法（【参数列表】）【throws 异常类列表】
                 {
                       语句序列；
                       【return【返回值】】；
                  }

     修饰符：指定方法的访问权限等  如public static（声明静态方法）没有返回值用void标记
     java不支持类之外的全程变量
    调用：方法（【参数列表】）

     声明main方法；public static void main(string args[])
2.4.2  参数传递
      实际参数向形式参数传递原则：基本数据类型，传递值；引用数据类型，传递引用；方法体内，如果修改引用类型的形式参数，同时修改对应的实际参数
     
   	常量形式参数  用final声明  
	final int value[]  中value[0]是对的，可以更改常量数组元素值，value=new int[4]是错的

可变形式参数：在形式参数类型之后加...，表示该形式参数数目可变，可变形式参数只能用在最后一个形式参数位置，并且一个方法最多只能有一个可变形式参数。如 public static void print(int... value)//可变形式参数，可将value视为int[]类型，可将可变形式参数作为一个数组编程。

2.4.3 方法重载
      方法同名但参数不同
2.4.4 递归方法
      基本要素：边界条件 递推通式
 
2.5 字符串  string 是一个类，属于引用数据类型
    字符串常量 变量
     用单引号括起来的是字符常量，如‘a’；用双引号括起来的是字符串常量，如“a”，空串只有“”
  +=能够用于字符串变量，其他复合赋值运算符均不能用于字符串变量
      字符串不是数组  与c/c++不同之处
2.5.2  字符串类特性
       readLine();  关键System.in.read(buffer),从标准输入流读字节到缓冲区buffer，返回读取字节数
       throws java.io.IOException 抛出IO异常
       MyInteger.parseInt(string s),获得整数八、十、十六进制字符串表示的整数值
       MyInteger.toString(int value,int radix);返回整数的radix进制形式字符串   
    

3 类的封装、继承和多态
3.1 类和对象
   面向对象程序设计(OOP)
   类是描述对象的数据类型，刻画一组具有共同特性的对象
   类是静态概念、对象是动态概念
3.1.1
   成员方法、成员变量统称为类的成员

p.s:类是有class修饰，而方法（函数）是带有返回值void、int 等修饰的，类 实例用"."调用方法
     实例化类
   声明：【修饰符】 类<泛型> 【ectends 父类】 【implements 接口列表】
          修饰符：public abstract final
          泛型：类的类型参数，带参数的类称为泛型类，就像c++中的模板类
   成员变量声明：【修饰符】 数据类型 变量 【=表达式】{，变量【=表达式】}  修饰符：pulic protected private static final
   成员方法：【修饰符】 返回值类型 方法（【参数列表】）【throws 异常类列表】
             {
                  语句序列；
                 【return【返回值】】；
              }
   成员方法重载 参数列表不同，成员方法同名 参数不能指定默认值

3.1.2 对象
     类的实例  instance
     构造实例:MyDate d1= new MyDate(); 
new CodeBlock02() // 声明了之后不赋值，没有办法后续对这个对象继续操作
CodeBlock02 code = new CodeBlock02(); // 把声明的对象赋值给一个变量，可以进行后续操作
code 就是你用来接收 new 出的实例的的“遥控器”，它指向这个对象在堆区的具体位置。
     对象获得一个实例后：就可以使用点运算符.引用对象中的成员变量和调用成员方法 语法格式：对象.成员变量
     d1.month =10;//引用成员变量
     d1.set(2012，1,1)；//调用类的成员方法 
     对象引用模型：类是引用数据类型，一个对象引用一个实例，含义为对象保存该实例的引用信息

3.2  类的封装性
   封装是面向对象的核心特性，是信息隐藏思想的具体实现技术
   java提供构造方法、析构方法、方法重载、设置访问控制权限等措施对类进行封装
3.2.1  构造与析构
    构造方法与类同名 构造方法通过new运算符调用
    设定了构造方法后，java不再提供默认构造方法
    拷贝构造方法：指参数是该类对象的构造方法
    析构方法：java的析构方法声明如下：public void finalize()  一个对象也可以调用析构方法释放对象自己
3.2.2
    this引用：java的每个成员方法都可以引用该方法的调用对象 用法如下：
    1.指代对象  this   指代调用当前方法的对象
    2.访问本类的成员 变量和方法  this.成员变量  this.成员方法（【参数列表】）
    3.调用本类重载的构造方法 this（【参数列表】）
在构造方法中，this()必须是第一行语句。不能使用this调用当前的构造方法
  
对象的关系运算与比较相等
    =、!=  判断相等，是否引用同一个实例，没有<，<=等，不支持运算符重载
    java约定一个类的equals()方法用于比较该类的两个对象是否相等，包括引用同一个实例和分别引用两个实例
    instanceof对象运算符  判断一个对象所引用的实例是否属于指定类，运算结果是boolean型
    如：d instanceoof MyDate 
3.2.3 访问控制
   1.类的访问控制权限：公有和缺省  公有权限使用public修饰符可被所有包中的其他类访问
                        缺省权限没有修饰符，仅能被当前包（当前文件夹）中的其他类访问
   2.类中成员的访问控制权限
      1.private 只能被当前类的成员访问，这是类希望隐藏的部分
      2.没有修饰符或缺省权限  说明可以被当前类以及当前包中的其他类访问，也成为在当前包中可见
      3.protected 该成员能被当前类及其子类或当前包中的其他类访问，也称为在子类中可见
      4.public 声明公有成员，该成员可被所有类访问
   范围；当前类-当前包-其他包的子类-所有类  以上范围逐渐递增
      public等权限修饰符不能用于修饰方法体中的局部变量。因为局部变量的作用域仅限于当前方法，对其他类不可见，不存在其他类对它的访问
   3.声明set（）和get（）方法存取对象的属性
      成员变量设置为私有权限 声明公有成员方法，提供获得和设置各种属性的功能
 

3.2.4 静态成员
    静态成员属于类，即使没有创建实例，也可以通过类名访问静态成员变量和调用静态成员方法
    静态成员也可以通过对象引用
    在静态成员方法体重，不能访问实例成员，不能使用this引用  
    不能声明方法的局部变量为static
　　在声明时可对静态成员变量赋初值，也可使用ｓｔａｔｉｃ声明静态初始化块，对静态成员变量进行初始化，只能访问类中的静态成员，且不能引发检测性异常，在类加载时执行
　　static  //静态初始化块
    {
      静态成变量员初始化；
     }
    封装减少了外部程序对类中数据的依赖，这就是类的抽象性、隐藏性、和封装性
3.2.5 浅拷贝与深拷贝
    浅拷贝：使用一个已知实例对新创建实例的成员变量逐个赋值   会影响被传递的对象
    当对象的成员变量是引用数据类型时，浅拷贝不能实现对象复制功能，需要深拷贝
    浅拷贝传递引用；深拷贝创建新实例
    当一个类包含引用数据类型的成员变量时，该类的拷贝构造方法，不仅要复制对象的所有非引用成员变量值，还要为引用数据类型的成员变量创建新的实例，并初始化为形式参数实例值，这种复制方式称为深拷贝

3.3 类的继承性
    继承是面向对象的核心特性，是实现抽象和共享、构造可复用软件的有限机制
3.3.1 由继承派生类
   被继承的类称为父类或超类 新类称为子类或派生类 使用关键字extends声明一个类继承指定的父类
   格式：【修饰符】 class 类<泛型> 【extends 父类】 【implements 接口列表】
   java的类是单继承的，一个类只能有一个父类
3.3.2  继承原则及作用
    1.子类继承父类所有的成员变量
    2.子类继承父类除构造方法以外的成员方法
    3.子类不能继承父类的构造方法
    4.子类可以增加成员，可以重定义从父类继承来的成员，但不能删除他们
 object类  根类
    object类定义对象的基本状态和行为，它没有成员变量，提供一组供所有对象继承的方法
    当一个类没有声明父类时，java默认该类的父类是object。
  子类对父类成员的访问权限
    1.子类不能访问父类的私有成员，但可以调用父类的公有成员方法间接访问父类私有成员变量
    2.子类能够访问父类的公有成员public和保护成员
    3.子类对父类的缺省权限成员的访问控制，以包为界分两种情况
3.3.3 子类的构造方法
    可以使用“super引用”调用父类的构造方法  格式：super（[参数列表]）
   默认执行super()
    1.当一个类没有声明构造方法时，java提供默认构造方法，调用super()执行父类无参数构造方法
      一个类通常要声明无参数的构造方法，即使自己不用，也要为子类准备着
    2.如果子类的构造方法没有调用super()或this()，java将默认执行super()。

3.4 类的多态性
    方法的多态和类型的多态
    方法的多态包括方法的重载和覆盖，为一种功能提供多种实现；类型的多态表现为，子类是一种父类类型
3.4.1 子类重定义父类成员
     包括：1.重定义父类的成员变量，则隐藏父类的成员变量
           2.重定义父类的成员方法，如果参数列表和返回值类型均相同，则覆盖父类的成员方法；如果参数列表不同，则重载父类的成员方法。如果参数列表相同而返回值类型不同，编译器会指出存在二义性的语法错误
      在子类的实例成员方法中，可使用“super引用”访问被子类隐藏的父类同名成员变量，调用被子类覆盖的父类同名成员方法，语法格式如下：
           super.成员变量  //当子类隐藏父类成员变量时，引用父类同名成员变量
           super.成员方法  //当子类隐藏父类成员方法时，引用父类同名成员方法
     super将当前对象作为其父类的一个实例引用  注意：静态方法中不能使用super引用
    不能重载析构方法（没有参数）
3.4.2 类型的多态
   hasA  包含：eg. Person对象通过birthday成员变量引用一个Mydate对象
   isA   继承
    1.子类对象即是父类对象
    2.父类对象引用子类实例
      赋值相容 子类对象是父类对象；父类对象不是子类对象   Person p=new Student()；
    一个Object对象能够引用任何类的实例，如：Object obj =new Person();
    子类对象调用父类方法，参数可以为父类对象或子类对象
    一个类需要声明自己的equals（）方法，比较自己声明的各成员变量值
3.4.3  编译时多态和运行时多态
    1.编译时多态  在编译时能够确定执行多态方法中的哪一个，称为编译时多态，否则称为运行时多态
      方法重载都是编译时多态，根据实参的数据类型、个数、次序，编译时可以确定
      方法覆盖表现出两种多态性，当对象引用本类实例时，为编译时多天，否则为运行时多态
    2.运行时多态
      当父类对象引用子类实例时，究竟执行谁的方法？
      程序运行时，java从实例所属的类开始寻找匹配的方法执行，如果当前类中没有匹配的方法，则沿着继承关系逐层向上，一次在父类或各祖先类中寻找匹配方法，直到Object类
3.4.4  多态的方法实现
     toString() 和equals()等方法被所有类继承
    1.多态的toString()方法
       一个类需要声明自己的toString()方法，覆盖父类或Object类的toString（）方法
    2.多态的equals（）方法
      1.子类扩展父类equals（）方法
      2.object类的equals（Object）方法
         比较两个对象是否引用同一个实例
      3.子类覆盖Object类的equals（Object）方法
         
3.5 类的抽象性
3.5.1 用继承刻画包含关系
3.5.2 抽象类
      使用关键字abstract声明的类，使用abstract声明的成员方法称为抽象方法
      抽象方法只有方法声明没有方法体
      抽象类不能被实例化   构造方法、静态成员方法不能声明为抽象方法
      包含抽象方法的类必须被声明为抽象类
      如果一个类声明继承一个抽象类，它必须实现父类的所有抽象方法，否则该类必须声明为抽象类
      抽象类用于描述抽象概念，抽象方法提供方法声明与方法实现的分离机制；子类继承抽象类的抽象方法，继承了父类的约定，子类可以根据自身的实际需要，给出抽象方法的具体实现，不同的子类可以有不同的方法实现。因此，一个抽象方法在多个子类中表现的多态性，使子类具有共同的行为能力
3.5.3  最终类
      用关键字final声明 不能被继承，没有子类 
       抽象类不能被声明为最终类
 声明最终方法：最终方法不能被子类覆盖，最终类中包含的都是最终方法。非最终类也可以包含最终方法
  public finaldouble areas()

4 接口、内部类和java API基础
    接口提供方法声明与方法实现相分离的机制，使多个类之间表现出共同的行为能力。接口机制使java具有实现多继承的能力。内部类使类具有嵌套结构

4.1 接口与实现接口的类  
       interface 是一组抽象方法、常量和内嵌类型的集合。接口是一种数据类型，接口采用抽象的形式来描述约定，因此接口只有别类实现之后才有意义
      一个接口可被多个类实现。接口声明的抽象方法在实现接口的多个类中表现出多态性
   1.声明接口
      【public】 interface 接口<泛型> 【extends 父接口列表】
       { 
            【public】【static】【final】 数据类型 成员变量=常量值；
            【public】【abstract】返回值类型 成员方法【（参数列表）】；
        }
      说明：1、接口中的成员变量都是常量，声明时必须赋值；不能声明实例成员变量
            2、接口中的成员方法都是抽象的实例成员方法，默认修饰符为public abstract，不能声明为static
            3、接口中不能包含构造方法，因为构造方法不能是抽象的
            4、接口的访问控制权限是public货缺省
            5、接口没有任何具体实现，也不能创建实例
  -able接口：表示一种对象属性，可.... ；其中Clonable、Serializable接口没有常量，也没有声明方法，称为标记接口，用于标记某个属性

2.声明实现接口的类

用关键字implements声明一个类实现指定接口，语法格式如下：
 【修饰符】class 类<泛型> 【extends 父类】 【implements 接口列表】
  一个类可以实现多个接口，多个接口之间用逗号分隔 
  一个接口通常约定某个性质，或做某件事；一个类声明实现指定借口，说明该咧具有这些接口约定的性质
  一个抽象类如果声明多个接口，则它必须实现（覆盖）所有指定接口中的所有抽象方法
方法的参数列表必须相同，否则它必须声明为抽象类
接口是多继承的
  一个接口可以继承多个父接口
接口是引用数据类型
  接口对象不能调用接口中没有声明的方法，否则语法错

接口与抽象类的区别
  从语法和作用上看，接口与抽象类很像，都是通过抽象的约定来定义类型，从而提供方法声明与方法实现分离的机制。
差别：
   1.抽象类为子类约定方法声明，抽象类可以处给出部分实现，包括构造方法等；抽象方法在多个子类中表现出多态性。类的单继承，使得一个类只能继承一个父类的约定和实现
   2.接口为多个互不相关的类约定某一特性的方法声明，在类型层次中表达对象拥有的属性。接口没有实现部分。接口是多继承的。一个类实现多个接口，就要多种特性，也是多继承的

单继承和多继承
 1.类的单继承的优点
      类和接口都是对类型的扩展
    接口为操作描述抽象的约定，没有实现。多继承，使得一个接口能够继承多个父接口的抽象约定
 2.接口的多态性
   接口多继承不存在二义性问题
3.类的多继承存在二义性问题

4.2 内部类和内部接口
  内部类和内部接口是声明在其他类或接口内部的内嵌类型，包含内嵌类型的类或接口称为外层类型  
  内嵌类型有两个目的：类型嵌套和对象嵌套 静态内嵌类型用于定义类型的嵌套结构，实例内嵌类型用于定义对象的嵌套结构
  内嵌类型是外层类型的成员，内嵌类型既有类型的特性，也有类中成员的特性

1.内部类作为类型的特性
  内嵌类型不能与外层类型同名
  内部类中可以声明成员变量和成员方法，内部类成员可以与外部类成员同名；内部接口中可以声明成员常量和抽象成员方法
  内部类可以继承父类或实现接口
  可以声明内部类为抽象类，该抽象类必须被其他内部类继承；内部接口必须被其他内部类实现

2.内部类作为成员的特性
  1.使用点运算符引用内嵌类型，语法格式：外层类型.内嵌类型
  2.内部类型具有类中成员的4种访问控制权限。当内部类可被访问时，才能考虑内部类中的成员的访问控制权限
  3.作为成员，内嵌类型与其外层类型彼此信任，能访问对方的所有成员
  4.内部接口总是静态的内部类可以声明时静态的或实例的，静态内部类能够声明静态成员，但不能引用外部类的实例成员；实例内部类不能声明静态成员
  5.在实例内部类中，使用以下语法格式引用或调用外部类当前实例的成员变量或实例成员方法
  外部类.this.成员变量
  外部类.this.实例成员方法

静态内嵌类型用于定义类型的嵌套结构
实例内部类用于定义对象的嵌套结构

4.3 Java API基础
4.3.1 java.lang包中的基础类库
1.object类
2.math数学类
  是最终类，不能被继承
3.comparable可比较接口
4.基本数据类型的包装类
5.string字符串类
6.StringBuffer字符串缓冲区类
7.class和package类
  this.getClass().getName()//返回当前对象所属类名字符串
8.system系统类
9.Runtime 运行时类

4.3.2 java.util包中的工具类库
1.日期类
date calendar gregoriancalendar
2.comparator 比较器接口
  约定多种比较对象大小的规则
  约定多种比较对象相等的规则
3.Arrays数组类
 排序
 二分法查找

4.4 泛型
  泛型（genericity）是对类型系统的一种强化措施，通过为类、接口方法设置类型参数，泛型使一个类或一个方法可在多种类型的对象上进行操作，从而减少数据类型的转换，避免类型转换的潜在错误，增强编译时刻的类型安全，增加软件可复用性，提高代码运行效率

1.泛型声明
  泛型指类、接口及方法声明的类型参数。带有泛型参数的类、接口及方法声明的语法格式如下，其中<>必需，通常使用单个大写字母作为类型参数，多个类型参数以逗号分隔
   【修饰符】 class 类<类型参数列表> 【extends 父类】 【implements 接口列表】
   【public】 interface 接口<类型参数列表> 【extends 父类接口列表】
   【public】【static】 <类型参数列表> 返回值类型 方法（【参数列表】） 【throws 异常类列表】
类型参数声明格式如下，其中，多个父类型以&连接
   类型变量 【extends 父类型列表】

2.泛型的必要性
 泛型T的实际参数必须是类，不能是int等基本数据类型

3.泛型的继承性及通配符
  Comparator<?>是所comparator<T>的父类型，？称为通配符
  泛型是必需的。它通过为类、接口及方法设置类型参数，对类型进行抽象，提供适用于更广泛类型的设计模板，增强编译时刻的类型安全，避免类型转换的麻烦和潜在错误。


5.异常处理
java语言的语法体系是严密的，语法检查是严格的，它在运行时能够捕获到所有运行错误：Java的异常处理提供语言级对运行时错误待处理机制；Java的内存自动管理提供内存资源使用的安全性。这些使得采用java语言开发的软件系统具有高度的可靠性、稳定性和容错性

5.1异常处理基础
5.1.1 异常处理机制的必要性
1.面向过程语言错误处理方式的缺陷  效率第一
  c语言不进行数据范围检查，数组下标越界时，系统不能识别错误 语义错演变成为逻辑错
2.面向对象语言的异常处理思想  正确可靠稳定比效率更重要
3.java语言是安全的

5.1.2 错误和异常
1.错误
指运行时遇到的硬件错误，或操作系统、虚拟机等系统软件错误，或操作错误
java.lang.error
2.异常
指在硬件、操作系统或虚拟机等系统软件运行正常时，程序产生的运行错误
例如：整数进行除法运算时除数为0，操作数超出数据范围，输入数据格式错误
非致命性的
java.lang.Exception
Error 和Exception 都是Throwable的子类
异常分为运行异常和非运行异常。运行异常是指由程序本身错误或数据错误所引发的异常，这类异常程序设计时大多可以避免；非运行异常是指由程序运行环境错误引发的异常，这类异常必须捕获并处理

3.RutimeException运行异常类
运行异常都是RuntimeException的子类
1.ArithmeticException 算术异常
2.NullPointerException 空对象异常
3.ClassCastException类型强制转换异常
4.NegativeArraySizeException负数组长度异常
5.ArrayIndexOutOfBoundsException数组下标越界异常
6.StringIndexOutOfBoundsException 字符串序号越界异常
7.NumberFormatException数值格式异常

4.程序对错误与异常的三种处理方式
1.程序不能处理错误。对于内存溢出等错误，由系统惊醒处理，java程序本身不能对错误进行处理
2.程序应避免而不捕获的异常。
3.必须处理的异常

5.2 异常处理措施
处理机制；异常类体系、异常处理的try语句、抛出自定义异常对象的throw语句、声明方法抛出异常的throws子句和自定义异常类
创建一个异常类对象的过程称为抛出（throw）异常
获得异常对象的过程称为捕获（catch）异常；由异常对象执行相应操作的过程称为处理异常，异常对象由捕获它的语句进行处理

5.2.1 异常处理语句
java提供try-catch-finally语句来捕获和处理一个或多个异常，语法格式如下，catch可以有多个，finally可以省略
try
{
<存在潜在异常的语句>；
}
catch
{
<捕获异常对象并进行处理的语句>；
}
finally
{
<最后必须执行的语句，无论是否产生异常，是否捕获到异常>；
}
如果所有catch子句都没有捕获ex，则ex将由java虚拟机捕获并处理，导致程序运行终止，就像没有使用try语句。因此，通常最后一个catch子句的异常类是Exception，能够捕获并处理所有异常对象

5.2.2 抛出异常
1.抛出异常对象的throw语句
一个异常对象可以由java虚拟机抛出，也可以由程序主动抛出
语法格式 ： throw  异常对象
2.方法声明抛出异常的throws子句
如果一个放阿飞产生异常，而该方法不想处理货不能处理该异常，则可以再方法声明时，采用throws子句声明该方法将抛出异常。格式如下：
  【修饰符】 返回值类型 方法（【参数列表】） 【throws 异常类列表】
throws子句的作用是，声明方法抛出指定异常，则方法的调用者必须捕获并处理该异常，这样实现了异常对象在方法之间逐级向上传递

5.2.3 定义异常类
java提供的异常类不能满足需要时，程序自定义异常类


第六章 图形用户界面  GUI
6.1 AWT 组件及其属性类
图形用户界面（GUI） java图形用户界面的组件和事件java.awt和javax.swing包共同提供，java.awt称为抽象窗口工具集
JDK1.1的委托事件模型取代了JDK1.0的层次模型。JDK1.2的Swing组件扩展了AWT组件的功能

6.1.1  AWT组件（abstract window tookit）
java.awt包主要由组件类、事件类、布局类、菜单组件类等组成
1.组件
是构成图形用户界面的基本成分和核心元素 
  组件是具有以下特性的对象：运行时可见，具有坐标位置、尺寸、字体、颜色等属性，可以拥有并管理其他组件，可以获得输入焦点，可以响应事件
  component是所有组件类构成树层次结构的根类，实际使用的组件都是component的子类
  一个组件在容器中的位置（x,y）是指组件左上角点相对于容器的坐标。容器的坐标系中，水平方向是X轴，垂直方向是Y轴
左上角点坐标是（0,0）

2.容器
  container 是一种特殊组件
  容器是一种特殊组件，它能容纳其他组件，在其可是区域内显示这些组件；一个容器中可以放置其他容器

3.窗口和面板
 窗口有标题栏和关闭控制按钮，有边框，可以添加菜单栏；窗口可以独立存在，运行时可以被移动、被改变大小。窗口是顶层容器，窗口不能包含在其他容器中。
 面板没有标题，没有边框，不可添加菜单栏；面板不能独立存在，必须包含在其他容器中，一个窗口可以包含多个面板，一个面板可以包含另一个面板。

4.框架和对话框
   window窗口类的子类有：frame框架和dialog对话框
   frame框架是一种框架，用作Java Application应用程序的主窗口，Frame带有最大化和最小化控制按钮
   对话框也是一种窗口，但不能作为应用程序的主窗口，它通常依附于一个框架，当框架关闭是对话框也关闭

5.标签Label
   标签组件用于显示字符串。便签只能显示信息，不能用于输入。

6.文本行 TextField
  文本行是一个单行文本编辑框，用于输入一行文字。

7.按钮 Button
按钮用于显示操作命令，执行一种特定操作
用户登录窗口
public class LoginFrame extends Frame {
	public LoginFrame() {
		super("User Login");//设置框架窗口标题
		this.setSize(200,130);//设置组件尺寸
		this.setLocation(300,240);//设置组件的显示位置
		this.setBackground(Color.lightGray);//设置组件的背景颜色
		this.setLayout(new FlowLayout());//设置容器为流布局，居中
		this.add(new Label("userid"));//创建标签，添加到框架上
		this.add(new TextField("user1",10));//创建文本行，10列
		this.add(new Label("password"));//
		this.add(new TextField(10));//创建10列的文本行
		this.add(new Button("Ok"));//创建按钮
		this.add(new Button("Cancel"));
		this.setVisible(true);//显示框架窗口
	}
	public static void main(String[] args) {
		new LoginFrame();
	}	
}
程序运行时，用户可以移动该窗口，改变窗口大小，但不能关闭，布局较乱，当窗口大小改变时，各组件的相对位置也随之改变

6.1.2 布局管理
Java采用布局管理器（layout manager）对容器中国的组件进行相对布局，当改变容器大小时，或者改变组件的大小，或者改变组件之间的相对位置，保证组件不会被遮盖并且容器没有空白区域
 Java提供多种风格和特点的布局管理器，每种布局管理器指定一种组件之间的相对位置。java.awt布局管理器主要FlowLayout流、BorderLayout边、GridLayout 网格和GridBagLayout网格包
  window窗口类的默认布局是BorderLayout,Panel面板类的默认布局是FlowLayout.如果一个容器需要改变其默认布局管理器，可以调用container容器类的setLayout()方法
1.流布局管理器
FlowLayou布局管理器提供按行布置组件方式，将组件从左至右顺序、一行一行地排列，当行放满时再放置到下一行。组件保持自己的尺寸，容器中一行的宽度随容器的宽度而变化

2.边布局管理器
BorderLayout布局管理器将容器划分为5个区域：东、南、西、北四条边和中间，add()方法省略位置常量，默认所有组件都放置在中部区域，后放置的组件覆盖先前放置的其他组件

3.网格布局管理器
将容器划分为大小相等的若干行乘若干列的网格，组件大小随容器大小而变化
GridLayout的组件放置次序是行优先，从第一行开始，从左至右依次放置，一行放满后自动转入下一行，每个组件占满一格。

4.网格包布局
GridBagLayout网格包布局是一种灵活的布局管理器，它将容器分成若干行和列网格，每个组件可占据其中的若干行或列的多个单元格

6.1.3 颜色和字体
1.颜色
color颜色类表示24位真彩色，color类声明white\black\red\yellow...等颜色常量，并提供以三原色值表示颜色的构造方法

2.字体
font字体类声明如下，一种字体由字体名、字形、字号的等属性组成

6.2 事件处理
6.2.1 委托事件模型
1.事件和事件源
事件（event）是指一个状态的改变，或者一个活动的发生。产生事件的组件称为事件源（event source）
2.事件类和事件监听器接口
java将事件封装成事件类，并为每个事件类定义一个事件监听接口（listener interface），约定事件处理方法，指定产生事件时执行的操作
一个图形用户界面的类声明实现一个事件监听接口，意味着该类将响应指定事件并提供事件处理方法。必须指明哪个组件要响应该事件
3.组件注册事件监听对象
一个组件能够响应的事件时有约定的，如按钮能够响应动作事件，窗口能够响应打开和关闭等窗口事件
 java在各组件类中声明了组件注册事件监听器方法，表示该组件要响应指定事件
 一个组件如果要响应多个事件，可以注册多个事件监听器；多个组件如果要响应痛一个事件，可以注册同一个事件监听器。这样，事件只传递给已注册的组件，不会被其他组件或容器获得。事件处理方法既可以由本类实现，也可以委托其他类实现，多个类可分工合作
UNICODE字符查询器
import java.awt.*;

import java.awt.event.*;

class QueryFrame extends Frame implements ActionListener {
	private TextField text_char, text_uni;
	private Button button_char, button_uni;

	public QueryFrame() {
		super("Unicode字符查询器");
		this.setBounds(300,240,280,90);
		this.setBackground(Color.lightGray);
		this.setLayout(new GridLayout(2,3,2,2));
		this.add(new Label("字符",Label.RIGHT));
		text_char = new TextField("汉字",10);
		this.add(text_char);
		button_char =new Button("查询Unicode码");
		this.add(button_char);
		button_char.addActionListener(this);//处理方法委托当前对象实现
		this.add(new Label("Unicode编码",Label.RIGHT));
		text_uni =new TextField(10);
		this.add(text_uni);
		button_uni=new Button("查询字符");
		this.add(button_uni);
		button_uni.addActionListener(this);
		this.addWindowListener(new WinClose());
		this.setVisible(true);
	}

	public void actionPerformed(ActionEvent ev) {
		if (ev.getSource() == button_char) {
			String str = text_char.getText();
			if (str.equals(""))
				return;
			char ch = str.charAt(0);
			text_char.setText("" + ch);
			text_uni.setText("" + (int)ch);
		} else if (ev.getSource() == button_uni) {
			String str = text_uni.getText();
			if (str.equals(""))
				return;
			int uni = Integer.parseInt(str);
			text_char.setText("" + (char)uni);
		}
	}

	public static void main(String arg[]) {
		new QueryFrame();
	}
}

class WinClose implements WindowListener {//实现窗口事件监听接口
	public void windowClosing(WindowEvent ev) 
	{
		System.exit(0);
	}

	public void windowOpened(WindowEvent ev) {}
	public void windowActivated(WindowEvent ev) {}
	public void windowDeactivated(WindowEvent ev) {}
	public void windowClosed(WindowEvent ev) {}
	public void windowIconified(WindowEvent ev) {}
	public void windowDeiconified(WindowEvent ev) {}	
}
窗口关闭事件是所有应用程序都要处理的事件，处理方式相同，可以委托其他类处理。
而按钮动作事件需要每个应用程序做特殊处理，不能委托其他类处理。

4.窗口关闭事件是所有应用程序事件驱动
1.不同组件的事件或同一组件的不同事件具有约定的质性次序
2.各组件的事件处理方法是否质性、执行次序以及执行次数，取决于用户操作
3.在一个事件处理方法中，按照语句次序顺序执行	

6.2.2 AWT事件类和事件监听器接口
1.AWT事件类
2.AWT事件监听器接口
  AWT事件监听器接口及其方法
 窗口事件、动作事件、鼠标移动事件、鼠标事件、键盘事件、焦点事件
3.AWT组件类中注册事件监听器的方法

6.3 Swing组件及事件
AWT组件不是跨平台的，从外观到控制都依赖本地从操作系统，称为重型组件。
为了实现图形用户界面的跨平台特性，java于JDK1.2推出swing组件，java建议用swing组件代替awt组件设计图形用户界面
swing组件是用纯java实现的轻型组件，没有本地代码，不依赖本地操作系统的支持。swing组件在不同操作系统上表现一致，并且有能力提供本地操作系统不支持的其他特性，支持可插入的外观感觉（Pluggable Look and Feel,PL&F）
swing是AWT库的扩展，所有swing组件都实现饿了accessible接口，支持可存取性；可以为swing组件设置多种边框；支持键盘操作；按钮、标签等组件能够添加图标对象
swing部分组件采用简化的MVC（model-view-controller，模型-视图-控制器）设计模式，组件包括视图和控制器功能，数据项则由一个相关模型存储和管理，提供插入和删除操作
swing组件在javax.swing包及其子包中，swing事件在javax.swing.event包中

6.3.1 swing组件与布局
1.swing组件类关系
JComponent是Swing轻型组件的根类，继承AWT的容器类java.awt.Container

2.Swing顶层容器
基于swing组件的图形用户界面，采用JFrame框架作为主窗口
JFrame和JDialog框架仍然是重型组件，不能直接将swing组件添加到JFrame和JDialog顶层容器中，而是要加到顶层容器包含的一个称为内容窗格的 （content pane）容器中，内容窗格是一个轻型组件

3.BoxLayout盒式布局和Box容器
BoxLayout 盒式布局管理器以水平或垂直方向放置组件，当改变容器大小时，多个组件将不会换行\列布局，而是调整组件大小仍然在一行\列排列
Box是使用BoxLayout的轻型容器

6.3.2文本显示和编辑组件及事件
1.标签 JLabel
增加功能：JLabel标签能够容纳一个Icon图形组件，这个特性体现了swing组件是容器
2.Icon 图标
Icon接口描述固定尺寸的图标，图标是一种图像，ImageIcon图标类实现Icon图标接口，用于从JPG或GIF图像生成图标
3.文本行和文本区
主要组件：JTextField JPasswordField JTextArea
JTextField 是单行文本编辑框，增加方法：水平对齐
JPasswordField 是JTextField J的子类，用于输入密码的一行字符串，以“*”代替
JTextArea 是一个显示纯文本的多行文本编辑框，它的基本操作与文本行类似，增加了接受换行符的多行控制
4.文本编辑组件响应的事件
  1.caretevent文本编辑事件
    当用户在JTextField  JTextArea 编辑时，每操作一个字符，将触发一次caretevent文本编辑事件
  2.actionevent动作事件
由于JTextField文本行中只允许输入一行内容，当用户按enter键时，将会触发ActionEvent动作事件。而JTextArea文本区允许输入多行内容，当用户按Enter键时，表示输入回车换行符，所以不会触发动作事件。如果要在JTextArea文本区输入完成后对内容进行处理，可添加按钮，通过按钮的动作事件进行处理

类.this 当前外部类实例  外部类的当前对象eg. 对话框所依附的当前窗口Frame.this==>Frame.Dialog

5.微调文本行组件及事件
JSpinner微调文本行组件在文本行编辑框右边带有一对上、下的箭头按钮，它既可以直接输入，也可以使用箭头按钮从一个有序序列中微调选择一个取值，键盘的上下方向键也可用于选择序列值

6.3.3 按钮组件
包括JButton按钮与选项按钮 组件JCheckbox JRadioButton 
1.按钮
JButton  增加功能：JButton表面可以带图标
2.复选框  方框
一组数据项中各项之间没有联系
JCheckbox 实现多项选择
3.单选按钮 圈点
一组数据之间各项之间有联系
一旦重新选择了一个数据项，则先前被选中的数据项随即自动变为“没选中状态”
JRadioButton
只有在同一个按钮组的多个单选按钮的选中状态才是互斥的
需要由JRadioButton类和ButtonGroupanniu 组共同实现
4.抽象按钮类
AbstractButton抽象按钮类定义按钮和菜单项的一般行为
AbstractButton的3种按钮都可以注册动作事件监听器。当用户单击复选框或单选按钮时，将改变它们的状态，触发ActionEvent事件

6.3.4 列表框和组合框
当可供选择的数据项较少且数据项名称和数目确定时，通常使用复选框和单选按钮，当数据项较多时，通常使用JList列表框或JComboBox组合框组件
1.列表框及其事件
  1.JList列表框
    该组件能够容纳并显示一组数据项，从中选择一个或多个数据项，默认为多项选择。JList的数据项具有线性关系，每个数据项对应一个序号（大于等于0）
  2.列表框模型
     JList的数据项由列表框模型存储并管理，数据项具有线性关系，有次序且元素可重复。当改变列表框模型中的数据项时，自动更改JList的显示
  3.列表框选择事件
     选中列表框的数据项，触发ListSelectionEvent列表框选择事件

2组合框 
JComboBoxz组合框由一个文本行和一个列表框组成，表现为一个右边带向下箭头的文本行，组合框既可以像文本行一样直接输入数据，也可以像列表框一样选择数据项，只是列表框平时是隐藏的，当用户单击箭头时，才显示列表框
 1.JComboBox组合框
    JComboBox类声明如下，包括构造、选中、注册事件监听器等方法
 2.组合框响应动作事件
    在组合框的下拉列表中选择数据项；或当组合框可编辑时，在文本行中按enter键，都触发ActionEvent事件

6.3.5 中间容器
1.滚动窗格
 JScrollPane 滚动窗格是带有滚动条的视图容器，用于为其他组件提供可滚动视图。JScrollPane自动管理垂直和水平滚动条，只要组件内容超过视图大小就会自动显示水平或垂直滚动条
  JTextArea JList 等组件没有带滚动条，可以将它们放置在JScrollPane滚动窗格中
2.分割窗格
 JSplitPane 分割窗格是包含两个组件的容器，组件之间有分隔条，拖动分隔条可以改变组件的大小，
 垂直分割时，两个组件从左到右排列；水平分割时，两个组件从上到下排列
 如果希望分割两个以上的组件，则可以采用多个嵌套的分割窗格

6.3.6 JOptionPane和JColorChooser对话框
1.JOptionPane 选项对话框
  JOptionPane定制多种形式的标准对话框，消息、确认和输入对话框
   "\""----代表一个双引号
2.JColorChooser选择颜色对话框
  
至于接口能不能new出来，说不能，是因为不能像用new实现类那样new出来，说能，是因为你用new必须要在这条语句中实现这个借口的所有方法

package contract;
public interface ISay {
     void sayHello();
 }


package jimmy;
import contract.ISay;

public class Program {
    
	public static void main(String[] args) {
        
		ISay say = new ISay() {          
            
			public void sayHello() {
                
				System.out.println("Hello java!");
            
			}
        
		};
    
	}

}

初看上去，就好象在“不提供接口实现的情况下，直接new了一个接口实例”。

观察bin目录下的class输出，会发现有一个类似Program。

class文件，如果反编译观察一下，发现原来是编译器自动生成一个类program

一个文件只能有一个public的类或interface

private static Equalable<?> equal[] = { new EqualName(), new Equalbirthday() };// 见例4.4
private static Comparator<?> comparators[] = { new CompareName(), new CompareBirthday() };
当不知道什么类实现了equalable<T>时，T用？代替，应该是哪个类实现了这个接口<>里就用哪个类



6.3.7 菜单组件
1.使用菜单的两种方式
  1.窗口菜单
    JMenuBar菜单栏、JMenu菜单，JMenuItem菜单项组件组成，窗口上添加菜单栏，菜单栏中添加菜单，菜单中添加菜单项或子菜单，这样形成了窗口菜单的多层结构。菜单栏添加在窗口上方，不受布局管理器控制
  2.快捷菜单
    快捷菜单相对于组件的，当鼠标指向某个组件时，单击鼠标右键，弹出的菜单称为快捷菜单。快捷菜单也是由若干 菜单项组成的，其结构相对简单，通常最多只有二级子菜单
2.菜单栏
  JMenuBar菜单栏是窗口中用于容纳JMenu菜单的容器
3.菜单
  JMenu菜单是一组JMenuItem菜单项或子菜单的容器，每个菜单带一个标题
  菜单提供add（）方法添加菜单项或子菜单。如果一个菜单中加入另一个菜单，则构成二级子菜单
4.菜单项
  JMenuItem菜单项是组成菜单或快捷菜单的最小单位，不可分解。
5.选择菜单项 
  复选菜单项和单选菜单项
  与JRadioButton单选按钮一样，一组单选菜单项也要包含在一个ButtonGroup按钮组中
6.快捷菜单
不添加在菜单栏上，依附于一个组件；用户单击鼠标时显示；不受布局管理器控制，显示快捷菜单时，必须指定其位置
7.工具栏
JToolBar工具栏是一种容器，其中可添加组件，可拖动约定放置在窗口上方
  运行时，当工具栏的拖动属性为true时，按住工具栏的标志块，可将工具栏拖动至窗口的四边，也可呈浮动状态

6.3.8 表格
1.JTable表格
  以表格形式显示多行数据项，每行由多列数据项组成。多行数据项呈线性次序，行号>=0.双击表格中的单元格，即可修改表格内容。JTable没有带滚动条
2.表格模型
  JTable数据项的存储及管理操作由表格模型类提供。javax.swing.table.TableModel是表格模型接口，DefaultTableModel是实现该接口的默认表格模型类，声明

6.4 图形图像
  图形：矢量图形（Graphics）
  图像：映像，输出时，以数字方式控制显示设备实现原来景物的重现，图像文件的格式有BMP\JPG\GIF等

6.4.1 图形设计
1.坐标点类
  java.awt.Point
2.图形类
  java.awt.Graphics
3.组件绘图方法
  java.awt.Component中
        public void paint(Graphics g)
        public void repaint()
        public void update(Graphics g)
4.画布
  通常在画布上绘制图形。java.awt.Canvas  画布组件用于绘制图形

6.4.2 图像
1.image图像类
  java.awt.image图像类是抽象类，提供获得绘图对象、图像缩放等功能
2.Graphics支持显示图像
  java.awt.Graphics提供显示图像drawImage()方法
  显示图像的组件必须实现java.awt.image.ImageObserver图像观察器接口，由于Componet类实现了ImageObserver接口，所以所有组件都可以作为图像观察器来显示图像

第七章 多线程
7.1 操作系统中的进程与线程
1.进程  
  是一个程序关于某个数据集合的一次执行过程，是操作系统进行资源分配和保护的基本单位
  特性：结构性、独立性（是系统调度的独立单位）、动态性、并发性、交互性
2.线程
1.引入线程机制的动机和思路
  基本思路：把进程的两项功能--“独立分配资源”和“被调度分派执行”分离，前一项仍由进程完成，后一项任务交给线程的实体完成；这样，进程作为系统资源分配与保护的独立单位，不需要频繁的、地切换；线程作为系统调度和分派的基本单位，会被频繁地调度和切换
2.线程的定义和特性  
  线程（thread）是进程中能够独立执行的实体（控制流），是处理器调度和分派的基本单位。线程是进程的组成部分，每个进程内允许包含多个并发执行的线程。同一进程中的所有线程共享进程获得的内存空间和资源，但不拥有资源
  支持多线程的进程称为多线程进程
线程的特性：结构性（是操作系统调度的基本单位）、动态性、并发性共享性
3.线程的状态
包括：新建、就绪、运行、阻塞、终止
4.线程调度
  采用剥夺方式；
  常用：高优先级线程剥夺低优先级线程运行；二是当运行线程时间使用完后被剥夺处理器

3.并发程序设计
  顺序程序设计（sequential programming）：程序模块按语句次序顺序执行；
特性：执行的顺序性、运行时的封闭性、执行结果的确定性、计算结果的可再见性
  并发程序设计（concurrent programming）：将一个程序分成若干可同时执行的程序模块，每个程序模块和它执行时所处理的数据集合组成一个进程，因此，一个程序在运行时由并发执行的多个进程共同完成指定任务。一个进程中有包含多个并发执行的线程，操作系统以进程作为系统资源分配的基本单位，以线程作为系统调度的基本单位。特性如下：1、不具顺序性，由操作系统调度
                        2、运行环境不再是封闭的，一个线程的执行可能影响其他线程的执行结果，因此，程序的运行结果具有不确定性，计算过程具有不可再现性
                        3、共享变量的多个线程（称为交互线程）之间实现线程通信，能够写作完成一个任务，也会出现与时间有关的错误。因此，必须对并发执行的交互线程进行有效控制，协调它们并发执行的次序和相对速度，确保互斥地访问共享变量以及通信同步，保证运行结果正确
                        4、并发多线程程序设计的优点是,提高了系统性能，具体表现为快速切换线程、减少系统管理开销、线程通信易于实现、并发程度高、节省内存空间等

7.2  Java线程对象
java支持内置多线程。java语言包中的Ruannable接口约定线程的执行方法，Thread类提供创建、管理和控制线程对象的方法

7.2.1 Ruannable接口与Thread类
1.Ruannable接口
   只声明了run()方法，是线程的执行方法  一个线程对象必须实现run()方法以描述该线程的所有活动以及执行的操作，已实现run()方法称为该线程对象的线程体
2.Thread线程类
  具有封装线程对象的能力
  线程对象由Thread或其子类声明。构造线程对象时，可为其指定线程名；如果没有指定线程名，java将提供一个线程名
   线程对象执行run()方法，该run()方法既可以由线程自身提供，也可以由目标对象提供，目标对象指实现了Runnable接口的对象
   java提供两种方式实现多线程程序设计：继承Thread类和实现Runnable接口

e.g  声明继承Thread类的奇数/偶数序列线程

//首先执行的线程是main,主线程，此程序包含3个线程，并发地执行，main线程优于其他线程执行
线程启动语句的顺序不能决定线程的执行次序。线程启动后处于就绪状态，等待操作系统调度执行，线程何时执行、线程执行次序以及是否被打断均不由程序控制。如果线程执行时间过长或其他原因，线程执行将被中断，等待再次调度执行。因此，线程的运行结果具有不确定性。本例中，当输出序列较长时，奇数线程和偶数线程交替运行，交替输出序列值（线程启动了，只是不会从头开始运行，但可能被打断）

Thread类声明带有Runnable接口对象的构造方法
   public Thread(Runnable target)  //target指定线程的目标对象，接口类型
声明一个对象实现run()方法可以作为一个线程对象的目标对象，为一个线程对象提供线程的执行的run()方法
Thread的子类声明非空的run（）方法覆盖Thread类的run（）方法，其对象执行的是自己的run（）方法，不需要目标对象

3.两种创建线程方式的比较
   前两例分别使用两种方式创建线程，效果相同，那么，在实际编程中如何选用这两种方式呢？
  1.继承Thread线程类。  缺点是不适用于多继承
  2.实现Runnable接口。当一个类已继承一个父类，还要以线程方式运行，就要实现Ruannable接口，作为线程对象的目标对象使用，需要同时声明一个Thread线程对象

7.2.2 线程对象的优先级
 Java提供10个等级的线程优先级，分别用1-10，优先级最低为1，最高为10，默认值是5.
 public final int getPriority  //获得线程优先级
 public final int setPriority(int priority)   //设置优先级
拥有更高优先级的线程能够更快地进入运行态

7.2.3 线程对象的生命周期
1.Thread.State类声明的线程状态
  Thread.State是Thread类的内部枚举类，其中声明6中线程状态，声明如下：
  新建态、运行态、阻塞态、等待态（等待时间不确定）、等待态（等待时间确定）、终止态
导致线程进入阻塞态（BLOCKED）或等待态的原因有多种，如输入\输出、等待消息、睡眠、锁定等。
终止态（TERMINATED） 原因：运行结束或被强行终止
2.Thread类中改变和判断线程状态的方法
  start（）启动新建态的线程对象，一个线程只能启动一次
  sleep()线程睡眠。使当前线程停止执行若干毫秒，线程由运行态进入等待态，睡眠时间到，线程可再次进入运行态。
  interrupt（）线程中断，设置运行中断标记，与之配合使用的还有判断线程是否中断的方法，此方法为当前线程设置一个中断标记，以便于run()方法运行时使用isInterrupted（）方法能够检测到，此时，线程在sleep()之类的方法中被阻塞时，由sleep()方法抛出线程中断异常，可捕获这个异常进行中断处理操作
注意：interrupt（）方法只是为线程设置了一个中断标记，并没有中断线程运行，该方法没有抛出异常，一个线程在被设置了中断标记之后仍可运行。isAlive()返回true。实例方法isInterrupted（）测试线程对象的中断标记，并不清除中断标记
当抛出一个InterruptedException异常时，记录该线程中断情况的标记将会被清除，这样再调用isInterrupted（）返回false

eg. 7.3 设计滚动字演示线程状态及改变方法
  线程启动后执行run()方法，将字符串原第0个字符连接到字符串最后，通过线程睡眠控制字符串显示一段时间，再次重新循环移位字符串，达到人眼看起来像是字符串在移动的效果。
     str.substring(1)+str.substring(0,1)//从右到左

7.2.4
  定时器与图形动画设计
动画（animation）都是利用人眼的视觉特性形成的。
图形动画设计的原理是，在画布上绘制一幅图，停留一点时间后，用画布背景色重画这幅图，就擦掉了原图；错开一些位置重画图形并停留一点时间，再擦除、重画，反复执行，从人的视觉效果来看，就好像图形在移动
  动画设计需要使用线程技术，利用线程对象睡眠来控制画图和重画时间，睡眠时间长则移动较慢，反之移动较快。当需要周期地执行某些操作，除了使用线程外，还可以使用swing的timer组件
  timer许建实现定时器功能，一个timer对象，每隔delay时间，执行actionevent事件
 EG.7.4 弹弹球，使用定时器实现图形动画

7.3 线程的同步机制
  如果并发执行的多个线程间需要共享资源或交换数据，则这一组线程称为交互（interaction）线程。交互线程并发执行时相互之间会干扰或影响其他线程的执行结果。因此，交互线程间需要有同步机制
  交互线程存在两种关系：竞争关系和协作关系。对于竞争关系的交互线程需要采用线程互斥方式解决共享资源冲突问题，对于协作关系的交互线程间需要采用线程同步方式解决线程间通信及因执行速度不同而引起的不同步问题。线程的同步机制包括线程互斥和线程同步，线程互斥是线程同步的特殊情况

7.3.2 交互线程
1.无关线程与交互线程
  无关的并发线程在不同的变量集合上操作，即一个并发线程不会改变另一个并发线程的变量值
  交互的并发线程指他们共享某些变量一个线程的执行可能影响其他线程的执行结果，交互的并发线程之间具有制约关系。因此，线程的交互必须是有控制的，否则会出现不正确的结果。
2.并发执行的交互线程间存在与时间有关的错误
  交互的并发线程执行时，由于它们在不同时刻对同一个共享变量进行操作，线程之间相互影响，相互干扰，因此计算结果往往取决于这一组并发线程的相对速度，各种与时间有关的错误就可能出现

例7.5  并发执行的 多个存/取款线程存在与时间有关的错误

run()方法中国即使没有sleep(1)语句，线程也可能会被打断
避免错误的方法：多个线程串行、互斥地访问共享变量

7.3.2 线程间的竞争关系与线程互斥
1.线程间的竞争关系
极端情况，被阻塞线程永远得不到访问权，从而无法成功地终止
   死锁：一组线程如果都获得了部分资源，还想得到其他线程所占用的资源，最终所有的线程将陷入死锁
   饥饿：一个线程优于其他线程总是优于它而被无限期拖延。
2.线程互斥和临界区管理
  线程互斥（mutual exclusion）是解决线程间竞争关系的手段。
  把共享变量代表的资源称为临界资源（critical resource）,并发线程中与共享变量有关的程序段称为临界区（critical section）。
操作系统对共享一个变量的若干线程进入各自临界区有以下三个调度原则：
  一次至多一个线程能够在它的临界区
  不能让一个线程无限期地留在它的临界区
  不能强迫一个线程无限地等待进入它的临界区。特别地，进入临界区的任一线程不能妨碍正等待进入的其他线程的进展
总结为四句话：无空等待、有空让进、择一而入、算法可行
   操作系统提供“互斥锁”机制实现并发线程互斥地进入临界区，对共享资源进行操作。至于操作系统采用什么样的锁（信号灯、只读锁等）以及如何实现加锁和解锁等问题，java程序员并不需要关心，这些细节都由操作系统和java虚拟机处理好了，程序员只需要在程序中声明哪个程序段是临界区即可，采用java抽象的锁模型，就能够使程序在所有平台可靠地、可预见地运行

3.java的线程互斥实现
  java提供关键字synchronized用于声明一段程序为临界区，使线程对临界资源采用互斥使用方式。两种用法：声明一条语句，或者声明一个方法
  1.同步语句
	synchronized声明一条语句为临界区，该语句称为同步语句，格式如下
             synchronized（对象）
                语句
“对象”是多个线程共同操作的公共变量，即需要被锁定的临界资源，他将被互斥地使用《语句》是临界区，描述线程对临界资源的操作
  2.同步方法
     使用synchronized声明一个方法，该方法称为同步方法，语法格式如下：
 	synchronized  方法声明
   同步方法的方法体称为临界区，互斥使用（锁定）的是调用该方法的对象。该声明与以下声明效果相同：
              方法声明
              synchronized（this）
              {
                  方法体
              }
同步语句与同步方法的行为基本相似，只是前者的作用范围小，它只是锁住一条语句（或复合语句）而不是完整的方法

7.6 互斥的存\取款线程设计
  运行临界区的代码，即使线程执行被打断，也不释放对象锁，只有当线程执行完才释放对象锁。这样不仅使得任何时刻只有一个线程对同一个账户进行操作，而且保证每个执行的多个操作时连续的，期间不会被其他线程干扰。

7.3.3 线程间的协作关系与线程同步
1.线程间的协作关系
  知道其他线程的存在，而且受其他线程执行的影响。当合作线程中的一个到达协调点后，在尚未得到其伙伴线程发来的信号之前应阻塞自己 ，知道其他合作线程发来协调信号后方 被唤醒并继续执行。这种协作线程之间相互等待对方消息或信号的协调关系称为线程同步。
例 7.7 发送线程与接收线程
  
2.线程同步
 是解决线程间协作关系的手段。线程同步（synchronization）是指两个以上线程基于某个条件来协调它们的活动。一个线程的执行依赖于另一个协作线程的信号，当一个线程没有得到来自于另一个 线程的信号时则需等待，直到信号到达才被唤醒
   线程互斥是一种特殊的线程同步，即逐次使用互斥共享资源，也是对线程使用资源次序上的一种协调

3.线程同步机制
  操作系统实现线程同步有一种工具称为信号量和PV操作，它的指导思想源于采用多种颜色信号灯管理交通的方法，描述如下。
1.背景
  多个线程需要对同一个共享变量进行操作，所以多个线程间必须互斥地执行，即这些操作方法必须是互斥的
2.设置信号量
  为这些共享变量约定一个信号量（semaphore），设置信号量有多种状态，就像是交通信号灯一样。设置信号量状态有多种方式，既可以由两种状态，也可以有多种状态。两种状态用bool值即可；多种状态表示一种轮流执行方式，如n=i时，约定执行i线程
   测试信号量状态的操作称为P操作，改变信号量状态的操作称为V操作，这两种操作时互斥的，并且执行时不能被打断
3.线程根据信号量状态而执行
  多个线程间彼此根据信号量的状态确定该执行谁，当一个线程开始执行时，它先要测试信号量的状态，如果状态合适，则执行，进行相关操作并更改信号量状态，唤醒其他等待线程执行；否则等待，使线程自己处于阻塞状态，直到唤醒再次执行。
  这样，交互的并发线程之间通过交换信号来达到调整相互速率，保证线程协调运行的目的。利用信号量和P，V操作既可以解决并发进程的竞争问题，又可以解决并发进程的协作问题。

4.java的线程通信方法
  java.lang.Object类提供wait(),notify()和notify()All()方法实现线程间通信
     notify（） 唤醒一个等待线程
 这些方法可以被任意类的对象调用，并且声明为最终方法

例7.8 采用信号量和同步方法使发送线程与接收线程同步运行
在互斥的put和get方法中国，如果只有wait方法而没有notify（)方法，则线程死锁
例7.9 发牌

第8章 输入/输出流和文件操作
文件是信息的一种组织形式，是存储在外部存储介质上的具有标志名的一组相关信息集合。
流是指一组有顺序、有起点和终点的字节集合，是对数据传输的总称或抽象。
在java.io包中

8.1 文件和流
8.1.1 操作系统中的文件和目录概念
1.文件与文件系统
保存性
文件系统提供“按名存取”实现文件的存储和检索。
在操作系统中，对设备的访问也都是基于文件进行的
2.目录结构与文件检索
文件系统提供目录机制实现文件的“按名存取”。目录（directory）是文件系统组织和管理的基本单位，目录中保存它所管理的每个文件的基本属性信息（称为文件目录或文件控制块）
目录子目录具有层次关系。顶层的是根目录。树状结构。文件是这种树状结构的叶子节点，文件中不能包含另一个文件
在多级树状目录结构中，一个文件的全名由该文件的路径名和文件名组成。文件名是区分文件的唯一标志。
在windows系统中，目录也称为文件夹
3.文件的逻辑结构
文件是文件系统中最小的数据组织单位，目录机制提供文件之间的分类和组织方式。
文件组织包括两方面：逻辑结构和存储结构。
按逻辑结构可分为两大类：流式文件和记录式文件
   流式文件由字节序列或字符序列组成。如源程序、文本文件等是字符流式文件
   记录式文件是一种有结构的文件，包含若干记录。记录式文件内独立的最小信息单位，记录可进一步划分成若干个更小的数据项（item），是具有标志名的最小的不可分割的数据单位。数据项的集合构成记录，相关记录的集合构成文件。如学生基本信息文件，每个学生信息为一个记录，文件由若干学生记录组成，每个记录又可由学号、姓名、性别等数据项组成
   流式文件也可以看成是每个记录只有一个数据项的记录式文件，而任何记录式文件都可以看成是以字节为单位的流式文件
4.文件的存取方式
   1.顺序存取是指按记录顺序进行读写操作的存取方式。
   2.随机存取是指按记录序号进行读写操作的存取方式。
   3.索引存取。是基于索引文件的存取方法  按记录键来编址
5.文件的使用方式
  针对用户和应用程序两种不同的对象，操作系统通过操作接口和应用程序接口两种方式提供其功能和服务，对文件系统亦是如此
  1.操作接口：操作系统将其功能和服务以操作命令形式提供给用户，用户以手动方式对文件系统等进行操作，实现人机交互功能。文件操作命令包括MS-DOS系统提供的md cd dir type等命令；windows系统提供的资源管理器窗口作为管理文件和目录的图形用户界面，用户在其中使用鼠标以手动方式进行创建文件夹、打开文件夹、移动文件夹等操作
  2.应用程序接口（API）：操作系统将其功能和服务以系统调用（system call）形式提供给应用程序。所有用户操作能够实现的功能都能通过系统调用在应用程序中实现
  程序设计语言通常将系统调用设计成库函数，目的是隐藏操作系统内部结构和硬件细节使系统调用更像函数调用。应用程序通过调用库函数就可以访问系统管理各种软硬件资源，调用操作系统功能，获得操作系统提供的服务

8.1.2 流的概念
1.流的定义和作用
 1.流的定义、方向、和读/写操作
   流（stream）是指一组有顺序、有起点和终点的字节集合，是对数据传输的总称或抽象。换言之，数据在两个对象之间的传输称为流
   数据流动具有方向，由外部输入流向内存，称为数据输入；内存向外部输出设备，称为数据输出。按期方向，分为输入流和输出流
  流的基本操作由读操作和写操作，从流中取得数据为读，向流中加数据叫写。一个流只能进行读或写中的一种操作，或者读或者写，不能同时读和写。对输入流只能读，对输出流只能写。
 2.流采用缓冲区技术 
   提高数据传输效率，将一块内存空间设计成缓冲区（buffer），暂时存放待传送的数据。以数据块形式传送，能显著地提高数据传输效率。配备缓冲区的流称为缓冲流（buffered stream）
  写入数据时，系统将数据发送到缓冲区，而不是直接发送到外部设备。缓冲区自动记录数据，当缓冲区满时，系统将数据全部发送到相应的设备。如果在缓冲区写满之前就要进行数据传输，称为立即传输（flush）操作。当缓冲区空时，系统就会从相关设备自动读取数据，并读取尽可能多的数据充满缓冲区
 3.流的作用
   设计流的目的是使数据传输操作独立于相关设备。程序需要根据待传输数据的不同特性而使用不同的流，数据传输给指定设备后的操作由系统执行设备驱动程序完成。这样程序不需要关注设备实现细节，使得一个源程序能够拥有多种输入/输出设备，从而增强程序的可重用性。

2.流的存在
  以下四种情况存在数据流动问题
  1.控制台应用程序的标准输入/输出操作。
  2.文件读写操作。读文件操作存在输入流，数据从磁盘流向内存；写文件操作中存在输出流，数据从内存流向磁盘
  3.线程通信。数据从一个线程对象（内存）流向另一个线程对象(内存）
  4.网络通信。数据从一台计算机的一个进程（内存）通过网络流向另一台计算机的一个进程（内存）
3.java的流类和文件类
按照流中元素的基本单位:流可分为字节流（binary stream）和字符流（character stream）。按照流的方向性，流可分为输入流和输出流。每种流类都有输入流和输出流两个类
   1.字节流以字节为单位读/写流，用于传输非字符数据，如整数，浮点数，对象等。InputStream和OutputStream是字节输入/输出流的根类
   2.字符流以字符为单位读/写流，仅用于传输字符，包括各种字符集。Reader和Writer是字符输入/输出流的根类。
  file文件类挤在文件属性信息，RandomAcessFile随机存取文件类以随机存取方式进行文件读/写操作。

8.2 字节输入/输出流类
 最小单位1字节。
8.2.1 抽象字节流
1.InputStream 
  read()抽象方法每次从输入流中读取1字节，返回读取的该字节。read(byte[])方法每次读取若干字节到指定缓冲区buffer，返回实际读取的字节数
2.OutputStream
   public abstact void write(int value) throws IOException;
OutputStream的子类需要实现单字节的write（int）方法，其他write()方法都基于此方法

8.2.2 文件字节流
   对文件进行读/写操作中的数据传输功能必须由文件输入/输出流实现
 1.FileInputStream  实现read()读取1字节方法
 2.FileOutputStream  实现write（） 写入1字节方法
   append 参数指定文件的写入方式，默认值为false，重写方式，数据从文件开始处写入，这样会覆盖文件中原有的数据，原有数据将丢失；若为true，添加方式，数据添加在原文件末尾

例8.1  理解字节流，演示从字节流中读写数据的操作

java默认整数类型为int；read()方法希望通过返回值标记输入流结束，若读取的1字节看成是int整数，则没有负数，因此read()方法E能够以-1表示字节流结束

8.2.3 数据字节流
  以字节流作为数据源，提供从字节流中读写基本类型数据的方法，包括DataInputStream数据字节输入流类和DataOutputStream字节输出流类
1.DataInputStream 
2.DataOutputStream

例8.2 采用整数文件保存随机数徐柳，使用数据流读写整数

8.2.4 对象字节流
 每次读取或写入一个对象，称为对象字节流，包括ObjectInputStream 对象字节流类和ObjectOutputStream对象字节输出流类，它们都以字节流作为数据源
  public ObjectInputStream(InputStream in)throws IOException //以字节输入流作为数据源
把一个对象的表示转换成一个字节流的过程春各位序列化（serialization），反之，从字节流中重建对象的过程称为去序列化。对象能够序列化的标记是该类声明实现java.io.Serializable序列化接口，Seriazable是标记接口，其中没有方法。如果欲写入的对象没有实现序列化接口，则抛出java.io.NotSerializableException异常

例8.3 使用对象流读写对象文件

8.2.5 管道字节流
  前面讨论了存在与文件输入/输出操作中的数据流问题，数据在内存与外部设备之间流动，此外，数据还可以在内存的两个对象之间流动
  PipedInputStream  PipedOutputStream
一次数据传输操作需要两个管道对象--一个输入流和一个输出流，并且这两个管道流需要建立连接，之后，一个对象可以向管道输出流写入数据，另一个对象可以向管道输出流写入数据，另一个对象可以从管道输入流中读取数据。

例8.4 使用管道字节流实现的发牌程序 同例7.9

8.3 字符输入/输出流类
  字符流以字符为单位读写流，每次读写的最小单位是1字符。字符流包括字符输入流和字符输出流，Reader类及其子类实现多种字符输入流，writer类及其子类实现多种字符输出流，每个子类实现一种特定的字符流输入/输出操作。JDK1.0推出字节流，1.1推出字符流。由于存在不同字符集编码等问题，java建议使用字符流处理字符，处理Unicode字符还能读写GBK等其他字符集编码的字符

8.3.1 抽象字符流
1.reader 
  read()方法从字符流中读取一个字符，返回字符编码，范围为0-65535，如果输入流结束，返回-1
2.writer
  write(int ch)方法将ch低16位表示的一个字符写入字符输出流忽略ch的高16位
write(int)方法写入一个字符，read（）方法读取一个字符，参数和返回值都是int，而不是char，为什么? read（）方法为什么能够将-1作为输入流结束标记？
char(Unicode)字符占用2字节表示无符号整数，范围是0-65535，与byte,short相同，java将char也按int整数存储和运算，运算后再进行强制类型转换。再者，与inputstream和Outputstream相同，read()
和write()方法的参数或返回值都是int而非char

8.3.2 字节/字符转换流
实现unicode字符流与指定编码的字节流之间的转换
1.InputStreamReader
2.OutputStreamWriter

8.3.3 文件字符流
  以字符为单位对文本文件进行读写操作，是转换流的子类，将从文件字节流获得的字节转换成unicode字符，默认使用本机的字符集编码来读写字符  FileReader FileReader

8.3.4
  缓冲字符流；以缓冲流方式读写字符，提供读写一行字符串的方法，他们自己配有缓冲区
  BufferedReader   BufferedWriter

8.3.5 格式化字符输出流
  格式化字符输出流类声明若干print()和println（）重载方法，将基本数据类型，字符数组，字符串即对象等各数据类型参数值转换成字符串输出
  PrintWriter
例8.5 使用字符流读写文本文件
   
本例与8.2 8.3演示了一个问题的两种解法，整数/对象既可以保存在整数/对象类型文件中，也可以保存在文本文件中。这两种方式各有千秋，存于整数/对象类型文件中，数据隐蔽性强，但读取不方便，必须根据要求特别编写读取程序；在文本文件中，可使用Windows的“记事本”等软件打开文本文件，不必特别编写读入程序，但数据时公开的，无法隐藏。在实际应用中，可根据需要进行选择。

8.3.6 java标准输入/输出
  标准输入时指从键盘灯外部输入设备中获得数据，标准输出是指向显示器或打印机等外部输出设备发送数据。
1.标准输入/输出常量
  java.lang.System类中有3个常量in out err，用于实现标准输入/输出功能
  in 标准输入常量
 out 标准输出常量
  err 标准错误输出常量
in和out 的功能是从标准输入/输出流中读/写字符，从语义上看，它们应该是字符流，但它们的类型都是字节流，

2.PrintStream
  格式化字节输出流类声明print和println重载方法，将基本数据类型、字符数组、字符串及对象等各类型参数值转换成字符串输出。除了System.out外，其他写入字符流应该使用PrintWriter类代替PrintStream
例 8.6 标准输入问题讨论

中文windows系统默认GBK字符集

8.4 文件操作
8.4.1 文件类及其过滤器
 1.构造文件和目录对象
   class File
 2.File类提供的方法
    访问方法、获得或设置属性、文件操作方法、目录操作方法
 3.文件过滤器接口
   ？ *通配符
    1.FileFilter接口  需要实现accept()方法：过滤操作，是否接受file文件对象保留在文件列表中
    2.获得过滤后的文件列表  listFiles()方法
例8.7 显示带过滤器接口

8.4.2  文件选择对话框组件
1.JFileChooser 能够调用Windows的打开文件对话框和保存文件对话框，设置过滤条件，改变查看路径，从文件列表中选择文件
  showopendialog()方法显示打开文件对话框，showsavedialog显示保存文件对话框

2.JFileChooser的文件过滤器
  例8.8 文本文件编辑器和文件管理器


8.4.3 随机存取文件类
  RandomAccessFile 使用file pointer 实现文件随机存取
定位文件尾：rafile.seek(rafile.length());//将文件指针定位到文件尾，用于添加数据
例8.9 使用随机存取文件生成素数文件。

第9章 网络通信
  URL指定在Internet上的某个信息资源的地址，包含协议、主机、端口、文件名和引用
  socket通信是两台主机的两个进程之间的端-端通信，包括基于TCP连接的socket通信和基于udp协议的数据报通信  在java.net包中
9.1 网络编程基础
1.计算机网络与internet
  计算机网络是一群具有独立功能的计算机通过设备及传输媒体被互联起来，在通信软件的支持下，实现计算机间资源共享、信息交换或协同工作的系统
  internet服务种类很多，主要有web浏览，电子邮件，文件传输（FTP）、远程登录（Tenet）、电子公告板（BBs）、即时通信(qq)、网络电话（IP Phone）

2.TCP/IP
协议：规定和规则的集合称为协议
TCP/IP协议簇分4层：应用层、传输层、网络层、网络接口层（链路层和物理层）

3.Internet地址
  用地址标记计算机在网络中的位置。一个地址只能对应一台主机，但一台主机不一定对应一个地址。   internet地址识别：ip地址和域名系统
  ip地址是唯一的，ip地址由网络地址和主机地址组成，用以标志特定主机信息
  域名系统（DNS）：域名空间的划分、域名管理、和地址转换
 tcp/ip采用分层结构方法命名域名。用.号将各级域名分开，域的层次从右到左，分别称为顶级域名（一级域名）、二级域名、三级域名等。（eg.www.edu.cn）

4.URL
  uniform resource locator统一资源定位符：是为标志internet上资源位置而设的一种编址方式。在internet上的每个文件都有一个用URL来标志的地址
 基本结构： 传输协议：//主机【：端口】【/文件】【#引用】
  主机可以是ip地址或主机域名（eg.www.edu.cn）
   HTTP 80
   FTP  20 21端口
一个ip地址或域名能够唯一确定internet中的一台主机，而一台服务器可以提供多种服务，那么客户端如何识别服务器提供的服务？解决办法是通过端口指定服务，服务器为每种服务约定一个端口，不同端口提供不同服务，客户端通过端口指定需要的服务。例如，约定80端口提供web服务，客户端在浏览器输入的url地址中默认端口号是80，实际上，一个端口指定的是运行提供该服务的网络应用程序的一个进程

5.客户-服务器模式
 client-sever模式是指一个应用系统整体被分成逻辑上分离的两部分：客户端和服务器，服务器是提供某种服务而等待服务请求到达；客户端向指定服务器发出服务请求，服务器接收并处理请求，再向客户端返回处理结果，由客户端提供图形用户界面
  internet服务的运行模式都采用客户-服务器模式。
 这种应用系统的分布方式使得多台计算机能够分工协作共同完成统一的任务
ps:“客户机”和“客户端”是两个概念；“客户机”指计算机硬件主机，“客户端”指运行在客户机上的客户端软件；而“服务器”既指服务器硬件，也指服务端软件

9.2 使用URL访问网络资源
9.2.1 URL和IP地址
1.URL类
  1.创建url对象
    url类表示url地址。
  参数spec指定一个包含协议、主机、端口、文件名的完整URL地址；protocol指定协议；host指定主机，本机主机默认为localhost，本机ip地址用“127.0.0.1”指代，并非本机实际ip地址；port指定端口；filename指定文件名
  例如：URL url1= new URL("file://localhost/D/:/Programs Files/Java/docs/api/index.html");
       URL url2 = new URL("http://www.phei.com.cn");
FILE协议定位在局域网或匿名服务器上的文件。当URL使用FILE协议时，表示本机文件系统；当URL使用HTTP协议时，表示网络上的某个文件。如果指定未知协议，抛出MalfromedURLException异常
  2.获得URL对象属性
    没有端口号，getport（）返回-1
  3.使用流获得URL资源内容
    openstream() 返回一个InputStream字节输入流对象。
2.URLConnection 类
   一个URL表示在Internet上的一个文件名，通过URLConnection文件对象 可以获得指定文件的各种属性
  1.URLConnection类声明
   只支持HTTP协议
  2.使用URL类的openConnection()方法创建一个URLConnection对象
3.InetAddress类
  表示internet上一台计算机的主机名和其ip地址，提供将主机名解析为其IP地址的方法 
  主机名到ip地址的解析通过使用本地机器配置信息和网络命名服务（如域名系统DNS、网络信息服务NIS）来实现。inetaddress类的子类inet6address使用IPv6格式地址

9.2.2 使用选项卡窗格和编辑器窗格
JTabbedPane选项卡窗格和JEditorPane编辑窗格等复杂Swing组件用于设计图形用户界面
1.JTabbedPane选项卡窗格
   该选项卡窗格提供多页面技术组件，它允许多个组件共享相同界面区域，在有限的空间内叠加多层页面，每页均可添加若干组件。单击页面标题可在多个页面之间切换。
  index指定页序号，范围是0-getTabCount()-1

2.JEditorPane编辑器窗格
   可编辑各种格式文本，包括纯文本、HTML文本和RTF文本
例9.1 查看指定URL的Web页编辑器及HTML文档

9.3 TCP Socket通信
9.3.1 TCP Socket通信原理
 1.互联网协议ip
   网络层协议核心是ip，ip是一个无连接的协议，负责将数据源从源转发到目的地，主要功能有：ip寻址、路由选择、分组及重组
  ip提供主机间的逻辑通信，提供尽力而为的服务（best-effort service），称为“不可靠”服务
  ip数据报有两种格式：IPv4 IPv6
  IPv4数据报由数据报头和数据域两部分组成，数据报头由长度为20位的固定部分和可变长度的选项数据组成。
 2.传输层协议TCP
  基本任务：延伸IP服务，将IP提供的在两个主机之间传输数据的服务，延伸到各主机上运行的诸多进程之间
  一个主机的ip地址和一个端口构成一个48位的socket，用来确定通信的一个端点，即一个进程。一对socket可标志通信的两端，一个发送进程和一个接收进程。Socket的本意是插座，在网络通信中称为套接字，指一条连接，就像是一根电源线就，一端是插头 ，另一端是插座。
 传输层有两个协议：TCP和UDP
    TCP:传输控制协议是一个面向连接的协议，通过建立TCP连接以及采取流量控制、顺序编码、应答和计时器等措施，TCP保证将数据按序、正确地从源主机中得到一个金春哥传递到目的主机得到指定进程。TCP将IP所提供的主机间不可靠传输服务转换成进程间的可靠的数据传输服务。
    UDP：用户数据报协议，是一个无连接的协议，以数据段为单位进行数据传输，每个数据报是一个独立信息，其中包括目标主机的IP地址和端口。可能丢失，不能保证数据传输的可靠性。

3.基于TCP连接的Socket通信
  TCP协议提供可靠的数据传输服务通过建立TCP连接实现的。一条“TCP连接”连接的两端是internet上分别在两台主机中运行的两个进程，一个是发送进程，另一个是接收进程，每个进程用一个Socket(IP地址和端口）唯一确定。一对Socket唯一标识一条TCP连接。TCP连接是全双工和点对点的，全双工是指数据可双向传输，点对点是指每条TCP连接只有两个端点。
  两个进程在通信之前，通过约定的端口建立一条TCP连接；当结束通信时，断开该TCP连接。与电话系统类似
  TCP连接提供双向字节流传输的可靠服务。发送方的TCP将用户送来的字节流划分成独立的数据报提交给网路层进行发送，而接收方的TCP将接收的数据报重新装配转换成字节流交给用户.TCP还要进行流量控制，以防止接收方由于来不及处理发送方发来的数据而造成缓冲区溢出

9.3.2 java的TCP Socket通信
1.ServerSocket类和Socket类
  实现TCPSocket通信。ServerSocket类提供TCP连接服务，Socket类提供进行通信的socket对象。
2.TCPSocket 通信流程
  一个实现socket通信的网络应用程序，由一个服务端程序和一个客户端程序组成，两端都是application应用程序。服务端程序包含一个提供TCP连接服务的ServerSocket对象和一个参与通信的Socket对象，客户端程序中只包含一个参与通信的Socket对象。服务端的ServerSocket对象提供TCP连接服务，连接成功后，实际进行通信的是服务端的socket对象和客户端的Socket对象。
例9.2-9.4 从点对点通信、一对多通信讨论到多对多通信

9.4 UDP数据报通信
UDP是传输层的一个简单协议，它只在IP协议上添加了应用程序多道处理和简单的错误校验功能。
  UDP被认为是无连接的
  DNS查询报文--不握手UDP给报文加段头-网络层-封装在IP数据报中-域名服务器
9.4.1 UDP数据报
  需要datagramPacket和datagramsocket两个类配合。前者将待传输数据封装成数据报包对象，再由数据报套接字datagramsocket提供的send()和receive()方法进行发送或接收操作
1.数据报包
  datagrampacket是数据报包类，待发送和待接收的数据报包格式不同
 1.待发送的数据报包
   创建数据报包对象
   创建：必须指定目标主机的ip地址和端口
 2.待接收地点数据报包
   创建-接收数据将保存在buffer字节数组中，length指定读取的字节数
2.数据报socket
  提供数据报的投递服务，包括发送和接收 （数据报包对象）

例9.5 采用UDP数据报通信实现的点对点聊天
TCP和UDP都实现了点对点的聊天功能，TCP先建立连接，确认对方在线再发送信息，所发信息肯定E呢被对方接收到，若连接中断，则发送失败，发送方捕获异常直到错误进行处理。而UDP数据报是不建立连接的，指定目标地址直接发送，若对方进程没有启动，或目标地址错误，或某个路由不正常，将导致数据报不能到达目的地，此时发送方并不知道。因此，就聊天功能而言，TCPSocket性能更好
 UDP主要面向请求/应答式交易型应用，一次交易往往只有一来一回两条报文交换，无连接方式的开销较小。也用于对可靠性要求不高的场合。如：时钟服务器提供的时间服务。


9.4.2 UDP组播数据报
  分布式系统中，进程间通信有多种类型，一对一称为单播（unicast）,一对多称为组播（multicast），一对所有称为广播（broadcast）。UDP支持单播和组播，组播通信用于视频会议、推送技术、为用户群进行软件升级、共享白板式多媒体应用等场合
  UDP组播数据报的通信方式是：约定一个组播地址，以组播方式向指定范围的IP地址发送信息；在此范围内的多台主机可接收该组播信息。接收统一台主机信息的多台主机 组成一个多播组，IGMP（Internet组管理协议）负责对IP多播组进行管理，包括多播组成员的添加和删除等
1.组播地址
  IPv4地址的D类地址提供组播业务，也称组播地址。要组播和接收组播的主机都必须加入到同一个组播地址。在同一个组播地址中的多个主机，可以再某个端口组播信息，也可以再某个端口接收信息
2.组播Socket
  组播数据报是UDP数据报的一种通信方式。MulticastSocket类实现UDP组播数据报通信，它是DatagramSocket的子类

例9.6 用于控制网络考试时间的组播
9.7 组播聊天

PING （Packet Internet Groper），因特网包探索器，用于测试网络连接量的程序 [1]  。Ping是工作在 TCP/IP网络体系结构中应用层的一个服务命令， 主要是向特定的目的主机发送 ICMP（Internet Control Message Protocol 因特网报文控制协议）Echo 请求报文，测试目的站是否可达及了解其有关状态 [2]  。


第10章  数据库应用
数据库存储的是通用化的相关数据集合，不仅包括数据本身，还包括数据之间的联系
java提供JDBC支持数据库应用，JDBC（java数据库连接）是基于java的、用于访问关系数据库的应用程序接口。

10.1 关系数据库系统
   数据库（DB）是长期存储在计算机外存上的、有结构的、可共享的数据集合。数据库中的数据按一定的数据模型描述、组织和存储，具有较小的冗余度、较高的独立性和易扩展性，可为不同的用户共享
  数据库系统（DBS）是采用了数据库技术的计算机系统，包括数据库、数据库管理系统（DBMS）、应用程序、数据库管理员（DBA）和用户。在不引起混淆的情况下，通常把数据库系统简称为数据库

10.1.1 关系模型
 数据模型（DM）是指表示实体与实体之间联系的模型。
 实体（entity） 实体集（entity set） 属性(attribute)
 关系数据库系统是支持关系模型的数据库系统。用二位表格表示实体集、用关键码进行数据导航的数据模型称为关系模型（relational model），其中数据导航（data navigation）是指从已知数据查找未知数据的过程和方法。关系模型的三个重要组成部分是数据结构、数据操纵和数据完整性规则
 1.关系模型的数据结构
  数据库中全部数据及相互联系都被组织成关系形式。关系模型的数据结构是关系。
   1.关系
  一个关系（relation）就是一张规范化二维表（table）,表示一个实体集。表中订单一列(column)表示实体的一个属性，也称为字段（field）；一行（row）表示一个实体，也称为元祖或记录（record）
 关系中国每个属性都有一个取值范围，称为属性的值域（domain）。每个属性对应一个值域，不同的属性可对应于同一个值域
   2.关系的性质
      关系模型要求关系必须是规范化的，基本关系具有以下性质
        1.列是同质的（homogeneous）,即每列的数据项数据类型相同
        2.不同的列表示实体不同的属性，必须以不同的列名相区别
        3.关系中不允许出现重复的行
        4.关系中每个属性都是不可分解的。换言之，不允许表中还有表
        5.关系是一个属性数目相同的元组的集合。
   3.关系模式
      对关系的描述称为关系模式（relation schema），关系模型是由若干个关系模式组成的集合。关系模式格式如下
     关系（列{ ，列}）
  带下划线的列为该表主键
   4.主键与外键
     能够唯一标志实体的属性集称为主关键字（primary key）,简称主键
     如果关系模式R中的属性K是其他关系模式的主键，那么K在关系模式R中称为外关键字（foreign key）.外键永不表达两个关系之间的联系（外部表的主键）

2.关系模型的数据操纵和数据完整性规则
   关系模型的操作主要包括数据查询和数据更新，数据更新包括插入、删除和修改。关系模型中的数据操作时集合操作，操作对象和操作结果都是关系。关系模型的存取路径对用户透明，使数据具有独立性和安全性，同时降低了应用程序的设计难度
  关系数据库必须满足实体完整性、参照完整性和用户定义的完整性
   1.实体完整性：（entity integrity rule）要求关系中一行组成主键的属性上不能有空值。如果出现空值，那么主键值就起不了唯一标志实体的作用
   2.参照完整性规则（reference integrity rule）定义为：如果属性集K是关系模式R1的主键，K也是另一关系模式R2的外键，那么，在R2的关系中，K的取值只允许两种可能：空值，或者等于R1关系中某个主键值。关系模式R1的关系称为“参照关系”，关系模式R2的关系称为“依赖关系”。这条规则的实质是不允许引用不存在的实体
   3.用户定义的完整性规则，是由用户根据特定需求而设置的数据完整性规则约束

10.1.2 客户-服务器结构的关系数据库系统
   数据库系统结构由集中式结构向分布式结构发展。“分布计算”概念经历了从处理分布、数据分布到功能分布的演变过程

1.数据库的结构与功能分布
  客户-服务器结构的关系数据库系统具有数据集中、功能分布的特点，将数据集中存储在数据库服务器上，服务器完成DBMS的核心功能，数据库的建立和维护工作由数据库管理员完成；客户端完成数据处理、数据显示、数据表示、用户接口等功能。两者采用请求-响应模式，即客户端提出服务请求、服务器响应请求并提供数据服务
  采用客户-服务器结构的关系数据可系统有Oracle,Sybase,SQL Server,DB2,MySQL等
2.数据库连接
数据库具有数据独立性（data independence）的特点,指应用程序与数据库的数据结构之间相互独立
应用程序不能之间存取数据库，需要数据库连接机制，应用程序在访问数据库之前，需要先建立与数据库的连接。
  根据通用性与专用性的原则，数据库连接技术主要有以下两大类：1.标准接口，为应用程序制定数据源的通用连接方式；2.专用接口，提供与一个数据库直接相连的专用连接方式，如Sybase,SQLServer,Orale,DB2等数据库有专用驱动程序
ODBC（open database connectivity,开放的数据库连接）是微软公司于1992年提出的基于SQL的数据库连接标准，适用于Microsoft Windows 和Sun Solaris操作系统，windows默认安装的一种工具
3.数据库应用程序
  开放数据库应用程序至少要两种语言：一种是支持数据库应用的程序设计语言，也称为主语言；另一种是对数据库中数据进行操作的数据操纵语言，目前操作关系数据库的标准语言是结构化查询语言SQL，由DBMS负责解释执行。
 在客户端有两种方式能够操纵服务端数据库中的数据：1.设计应用程序时，软件设计人员使用数据库客户端工具操纵数据；2.运行应用程序时，用户通过数据库应用程序进行特定操作操纵数据。

10.1.3结构化查询语言SQL
SQL（structured query language,结构化查询语言）是关系数据库的标准语言，对关系模型的发展和商用DBMS的研制起着重要的作用
所有关系数据库管理系统均支持SQL

1.SQL数据库的体系结构
sql数据库的体系结构要点如下
 1.一个sql模式（schema）是已命名的数据组，由表、授权、规则、约束等组成
 2.一个sql表由行集构成，一行是列的序列，每列对应一个数据项
 3.表有三种类型：基本表、视图和导出表。基本表（base table）是实际存储在数据库中的表，一个基本表表示一个关系模式；视图（view）是由若干基本表或其他视图定义的表；导出表示执行查询后产生的表
 4.用sql语句可对基本表和视图进行查询等操作，从用户角度看，视图也是表

2.sql的特点与组成
  sql是介于关系代数和元组演算之间的一种语言。sql是面向集合的描述性语言，是非过程性的，大多语句独立执行，与上下文无关
  sql由4部分组成：数据定义语言，数据操纵语言，数据控制语言和嵌入式sql的使用规定
  数据定义语言（DDL）:包括定义sql模式，基本表，视图，索引等结构，定义数据的完整性约束、保密限制等约束
  数据操纵语言（DML），提供数据查询和数据更新功能。查询语句描述并执行各种检索要求；更新语句进行插入、删除、修改等操作
  数据控制语言（DCL），包括对基本表和视图的授权，完整性规则的描述、事务处理控制等内容
  SQL的基本元素是命令、子句、运算符和集函数。由这些元素组成的语句，可以定义、查询和操纵数据。不区分大小写，习惯上SQL关键字采用大写形式。
9个命令动词
  数据定义：CREATE DROP ALTER  创建表、删除表、修改表
  数据操纵：INSERT UPDATE DELETE
  数据查询: SELECT
  数据控制；GRANT REVOKE 授予权限、收回权限

3.数据定义
  1.创建基本表
     CREATE TABLE 基本表
          （列  数据类型  【列级完整性约束】
           {，列  数据类型 【列级完整性约束】}
             【，表级完整性约束】）
列级完整性：NOT NULL;UNIQUE;DEFAULT.没有指定的时候，初值是NULL和不唯一

如果完整性约束条件涉及表的多列，则必须定义在表级上。表级完整性约束主要有3种子句：主键子句（PRIMARY KEY）、外键子句（FOREIGN KEY）和检查子句（CHECK）

FOREIGN KEY (stu_id) REFERENCES stuinfo(stu_id)  外键

  2.修改基本表
     创建基本表后，可以对其进行修改，包括增加列、修改列的数据类型及宽度、删除完整性约束条件。语法如下：
   ALTER TABLE  基本表
        【ADD 新列  数据类型 【列级完整性约束】】
        【MODIFY 列 数据类型】
        【DROP  完整性约束】  
  增加的列不能定义为NOT NULL
  
  3.删除表
   删除表的DROPTABLE语句的语法格式如下：
       DROPTABLE 表
 当一个基本表上没有创建视图或约束时，才能删除它，否则拒绝删除操作。

4.数据更新
  1.插入数据
    INSERT INTO 基本表
     【 （列1{，列2}）】
        VALUES（值1 {，值2}）
 没有指定列，则意味着是全部列  声明为UNIQUE的列不能取重复的值
  2.修改数据
    UPDATE 基本表
       SET 列=表达式{，列=表达式}
         【WHERE 条件表达式】
若省略WHERE子句，则修改表中所有的数据行
  3.删除数据
     DELETE FROM 表
           【WHERE 条件表达式】
5.数据查询
   SELECT [ALL|DISTINCT] 列表达式 {，列表达式}
           FROM  表
          【WHERE 条件表达式】
          【GROUP BY 列 【HAVING 条件表达式】】将满足HAVING子句表达式的结果集进行分组
          【ORDER BY 列 【ASC|DESC】】
% 统配符 

10.2 MySQL数据库

10.3  JDBC
10.3.1 JDBC的作用和功能
1.什么是JDBC
   （java DataBase Connectivity)java数据库连接，是基于java、提供连接、访问和操纵关系数据库的应用程序接口（API）
  需要JDBC驱动程序实现接口
2.JDBC驱动程序类型
  JDBC数据库应用程序必须使用JDBC驱动程序，JDBC驱动程序与ODBC驱动程序的区别主要有以下两点：    1.ODBC只适用于Windows平台，而JDBC具有跨平台特性
   2.ODBC数据源需要手工配置，JDBC在应用程序中指定数据库，不需要配置
 JDBC提供以下4种类型的驱动程序，其中前2种基于已有的驱动程序，部分由java实现，后两种是新设计的，全部由java实现
     1.JDBC-ODBC桥驱动程序：通过把JDBC方法翻译成ODBC函数调用，使java程序可以通过ODBC驱动程序访问数据库。有大量ODBC驱动程序可用，只能用于Ms Windows 和sun solaris ，不易移植，且运行速度较慢
     2.本地库Java实现驱动程序，是建立在已有专用驱动程序的基础上的，将JDBC方法翻译成本地已有的专用驱动程序。其间的翻译工作采用java语言实现，而专用驱动程序通常采用C语言编写。不具有跨平台性特点
    3.网络协议驱动程序，是一种全新结构的驱动程序，它以“中间件”的形式出现，由中间组件把JDBC方法翻译成数据库客户端请求，再向数据库服务器发送请求，中间件组件和数据库客户端通常位于中间层服务器上。此类驱动程序完全由java程序实现，它适用于基于网络的分布式应用。这种方式很灵活，但涉及网络安全问题。
    4.数据库协议驱动程序，也是一种全新结构的驱动程序，它的特点是应用程序直接与数据库服务器通信。这种方式需要数据库开发商的强力支持，提供基于特定数据库的网络插件，实现针对特定数据库的通信协议，使JDBC驱动程序通过网络插件直接与数据库服务器通信。此类驱动程序全部采用java编写。
3.JDBC基本功能和组成
  jdbc是按照面向对象思想设计的，完全用java语言编写
  java.sql包中的接口和类提供JDBC基本功能实现。
JDBC驱动程序必须实现Driver,Connection,Statement,ResultSet等接口。Driver接口用于装载和管理JDBC驱动程序，应用程序不直接使用它，而是通过DriverManager类使用Driver接口提供的功能。
  JDBC数据库应用程序设计与普通java应用程序设计的不同之处是：
    1.不能调用new运算符创建JDBC中类的实例，而由指定类的方法创建另一个类的实例
    2.connection,statement,resultset等接口已由指定JDBC驱动程序实现，因此，数据库应用程序中可以声明这些接口的对象引用实例

10.3.2 指定JDBC驱动程序
1.选择和安装JDBC驱动程序
  从驱动程序性能看，上面四种选择应该由4-1，
  MS Access数据库只提供ODBC驱动程序，只能使用JDBC-ODBC桥驱动程序；IBMDB2则提供了前三种类型 的JDBC驱动程序
  JDBC-ODBC桥驱动程序类是sun.jdbc.odbc.jdbcodbcdriver，它是JDK默认安装的，包含在运行时库rt.jar中，其他三种则需要特别安装和设置
2.eclipset添加sql驱动程序包 https://www.cnblogs.com/mxj961116/p/10604754.html
3.在应用程序中指定JDBC驱动程序
  在JDBC数据库应用程序中，首先需要指定驱动程序类型。可调用java.lang.class类的forName()方法指定JDBC驱动程序类。

10.3.3连接数据库
1.管理驱动程序
  DriverManager驱动程序管理器类装载指定JDBC驱动程序，创建与指定数据库的连接对象，声明如下
public class DriverManager extends Object  //驱动程序管理类
{
public static Connection getConnection(String url)throws SQLException//返回数据库连接对象
//一下参数url指定JDBC数据源的URL，user指定数据库用户名，password指定用户密码
public static Connection getConnection(String url,String user,String password)throws SQLException
}
JDBC使用URL表示JDBC驱动程序和数据源的位置，语法格式如下：
   jdbc:子协议：数据源
jdbc表示这个URL指定一个JDBC数据源，子协议指定JDBC驱动程序类型，数据源指定数据源名，示例如下
//以下创建与Access数据库student的连接对象，使用JDBC-ODBC桥接驱动程序
Connection conn =DriverManger.getConnection("jdbc:odbc:student");
//以下MySQL数据 url，包括JDBC驱动程序、数据库服务器域名、数据库名、用户名和密码
String url="jdbc:mysql://localhost/student?user=root&password=1234"
Connection conn=DriverManager.getConnection(url);//创建与指定数据库的连接对象

2.连接数据库
  connection 数据库连接接口负责管理java应用程序和数据库之间的连接，并创建数据库对象和statement语句对象
  DatabaseMetaData dbmd =conn.getMetaData();//创建数据库元数据对象
3.数据库元数据
  数据库元数据接口管理连接数据库的属性信息（称为元数据），包括驱动程序名及版本、数据库URL、数据库名及版本、用户名、以及关系模式、基本表结构、存储过程等
例10.1 连接指定数据库并获得数据库属性信息

10.3.4 执行sql语句
statement语句接口管理和执行sql语句，能够执行数据定义，数据更新和数据查询语句等SQL语句，三者返回值类型不同，所以，Statement接口声明多个execute（）方法如下：
  executeUpdate  executeQuery  close
1.执行数据定义和数据更新SQL语句
  应用程序能够操作的是临时表，可创建和修改临时表
  executeUpdate方法，可执行数据定义和数据更新sql语句。执行数据定义sql语句，创建和修改临时表，没有返回值；执行数据更新的SQL语句，包括INSERT、UPDATE、DELETE语句，返回执行所影响的行数
2.执行数据查询sql语句
  executeQuery()方法，执行数据查询的SELETE语句，返回值为数据查询结果集ResultSet接口对象

10.3.5 处理数据查询结果集
ResultSet   ResultSetMetaData ,前者提供存储数据查询返回的结果集，后者接口从结果集中获得表的属性信息（称为元数据），包括各列名，列的数据类型等表结构信息。
1.数据查询结果集
  包括确定当前行、移动行、获得或设置列值等
 1.当前行
ResultSet对象使用“当期行（current row）”概念表示将要对结果集进行操作的位置，行序号>=1.当前行由一个指针（cursor）指向，这个指针是默认的。由java管理，应用程序不需要直接使用指针，可以调用ResultSet接口中的以下方法移动或判断指针位置，为之后对当期行进行操作做准备。
  getRow  first previous next last absoulute(int row)  beforefirst
  如果有下一行，next()返回true
 2.当前行指定列的数据项值
   get方法返回当前指定列的数据项值，参数分别是列名或列序号，列序号>=1，返回值类型不同
  当生成ResultSet 对象 的Statement对象关闭时，Statement对象重新执行SQL语句时，ResultSet对象将自动关闭
2.结果集元数据
    ResultSetMetaData 结果集元数据接口从数据查询结果集获得表的属性信息，包括表名，列数，列名，列的数据类型，列宽等属性信息。

例10.2 显示数据查询结果集

3.通过ResultSet 结果集更新表
createStatement(int type,int concurrency)  type指定结果集是否可滚动，1003--指针只能从前向后移动，默认值   1004--结果集可滚动、对数据更新不敏感  1005--结果集可滚动、对数据更新敏感
  对数据更新是否敏感是指，当执行插入、删除、更新等其他SQL语句改变了表中数据时，当前结果集中的数据是否能够随之更新
  concurrency指定能否通过结果集更新表，取值为ResultSet以下常量之一1007--只读，默认值  1008--可更新


第11章 Web应用

11.1web浏览基础
1.web服务
  web(world wide web,www)以超文本标记语言（HTML）与超文本传输协议（HTTP）为基础，以友好的接口提供Internet信息查询服务的浏览系统。不是普通意义上的物理网络，而是一种信息服务器的集合标准
web服务器提供web服务，基本单位是web网页，每页包含文字、图形、图像、声音、动画等多媒体信息，以及指向其他web页的超链接
  从硬件角度看，web服务器指放置web站点的计算机；从软件角度看，web服务器指提供web功能的服务程序。web浏览就像Internet上一个超大型图书馆，一个web站点就是图书馆中的一本书，而一个web页就是书的一页
2.HTTP
  （HyperText Transer Protocol,超文本传输协议）是用在Internet上传送超文本的通信协议。HTTP是TCP/IP协议簇中的应用层协议，是web的核心
   web服务采用客户-服务器模式，也称为浏览器-服务器（browser-server）模式，是Client-Server的特例，它以浏览器作为客户端应用程序，提供图形用户界面，解释执行HTML文档
  两者之间通过交换HTTP报文来完成网页请求和响应，HTTP定义了这些报文的结构以及交换报文的规则
  当用户在浏览器地址栏输入一个web站点的URL或单击一个超链接时，浏览器就向服务器发送一个HTTP请求，该请求被送往URL指定的Web服务器；Web服务器接收到请求，搜索指定文件，将指定Web页的HTML文档及相关的图像、音频等文件传送给客户端；客户端由浏览器解释执行HTML文档，显示成图形用户界面的web页面
  这种分布式应用程序结构使得许多客户端可以共享运行在同一服务器上的相同页面
3.HTML
（HyperText Markup Language,超文本标记语言）是编写web网页的标准语言，它定义了web文档发布和浏览的基本格式。
   HTML是由HTML标记和文本组成的。HTML标记是描述信息的命令，HTML以标记表示及排列各对象。标记符号是<>，标记内容称为元素，HTML标记不区分字母大小写形式。HTML文档以<html>标记开头，以</html>标记结尾，中间包括两部分内容：头部（head）和主体（body）。头部描述浏览器所需信息，主体包含所要说明的具体内容。
  HTML文档基本结构如下
 <html>
    <head>
        <title>页标题</title>
    </head>
    <body>
       主体
    </body>
  </html>
HTML文档以ASCII码存储，可以使用任何文本编辑器创建和编辑HTML文档，HTML文档的文件扩展名是.htm或.html

4.静态文档与动态文档
  静态文档（static document）是由用户使用文本编辑器创建和编辑的。通常这种文档中的内容不会改变，在浏览器中每次查看效果相同
  动态文档（dynamic document）是当浏览器访问web服务器时由应用程序动态创建的。
  静态网页的优点是Web服务器负担较轻，只需要完成文件搜索功能，并且传输效率较高；缺点是功能欠缺，交互性差，运行结果单调，数据没有变化等。
 web技术发展方向是将HTML与程序设计语言相结合，即在HTML文档中嵌入程序设计语言。HTML较早的一种嵌入技术是Java Applet

11.2 Applet应用程序
  applet是可以嵌入web页的最小应用，又称小应用程序，它不能独立运行，必须嵌入HTML文档中，由浏览器解释执行。Applet体现了Java的嵌入式特性。

1.applet对于java的作用
  使web页不仅具有人机交互能力，而且具有动态特性
  applet是java崛起的法宝，对于java的发展和壮大具有不可磨灭的功绩
2.Applet的容器特性
  Applet是能够嵌入在web页中运行的一种特殊容器，java提供两个类用于实现Applet应用程序：java.applet.Applet类和javax.swing.jApplet类
  Applet类是Panel的子类。Applet是一种特殊的面板，所以Applet不能独立运行；Applet是容器，它能够容纳其他组件，具有容器的布局属性，默认布局管理器是FlowLayout
  Applet和JApplet的区别是，Applet容纳AWT组件；JApplet是Applet类的子类，可容纳AWT和Swing组件。下方叙述中，Applet泛指Applet类和JApplet类
  Applet的容器特性使得Applet应用程序能够实现Application应用程序图形用户界面的所有功能，既能够由多种组件组成图形用户界面，也能够响应并处理时间
  一个类晟敏继承Applet类或JApplet类，该类就是一个能够嵌入到Web页中运行的Applet应用程序。Applet应用程序必须声明为public，其中没有构造方法、析构方法和main方法

例11.1在Applet中显示当前日期和时间
  嵌入applet的HTML文档将上述.java编译生成的字节码文件.class嵌入到以下HTML文档中
<html>
    <head>
        <title>当前日期和时间</title>
    </head>
    <body>
       <Applet code="DateApplet.class" width=200 height=100></Applet>
    </body>
  </html>
jdk13没有appletviewer.exe，舍弃了applet，用不了。可加多个jdk版本解决
3.Applet应用程序的运行原理
  超文本由浏览器解释执行，而Applet由浏览器中的Java解释器解释执行。MS默认安装了java虚拟机，即使没有安装jdk，也能在浏览器中运行嵌入Applet的HTML文档
4.Applet的安全性限制
  限定applet行为，确保系统的安全性
   1.禁止读写本地计算机的文件系统，包括读取本地文件、写入本地文件、查看本地文件是否存在、将本地文件改名、创建一个本地目录等操作。
   2.禁止运行任何一个本地可执行文件
   3.禁止访问用户名、电子邮件地址等与本地计算机有关的信息
   4.禁止与除服务器外的任何一台主机通信

11.3 jsp
11.3.1 jsp原理
1.动态网页技术
  java Applet在HTML文档嵌入编译后的class类文件，类文件由浏览器中的java解释器解释执行，因此增加了浏览器的负担，降低了运行效率。在浏览器中执行纯HTML文档是效率最高的方法，这就是动态网页技术思想。
  动态网页（dynamic page）技术是，当浏览器访问web服务器时，在服务器执行应用程序，根据浏览器的不同请求，动态创建不同的HTML文档，再将该HTML文档返回给客户端的浏览器。这样，通过执行Web服务器的应用程序扩充了网页功能，增强了网页的动态特性
  最早的动态网页技术是CGI（common gateway interface,公共网关接口），目前动态网页技术主要有ASP,JSP,PHP(person home page)
  ASP(active server pages)是Microsoft公司推出的动态网页技术，它在HTML文档中嵌入VBScript和JavaScript脚本语言。ASP技术必须与IIS，ActiveX结合在一起，其运行环境仅限于Windows平台，不具有跨平台性。由于嵌入的是脚本语言，所以ASP每次执行都必须重新编译。因此，当访问量较大时，性能低很多，速度较慢。
2.Servlet
  动态网页技术，运行在web服务器的java应用程序，它可通过输出流对象动态生成HTML文档实现动态网页技术。在服务器执行，不需要图形用户界面；Servlet占用的密集资源很少，不会因访问量剧增而导致性能迅速下降
  显示饿了java语言优势，但是，没能区分静态数据和动态数据，在servlet中java代码全部都是静态内容，限制了程序功能的进一步扩充。
3.JSP文档
  （java server pages）是一种动态网页技术标准，是一种运行于web服务端的标记语言，它将java语言直接嵌入到HTML文档中，是目前功能最强，效率最高的动态网页制作技术
  jsp采用一次编译，多次多处执行的运行方式，第一次请求jsp页面时，服务器编译并执行jsp文档，再次请求只执行不重新编译。因此，jsp比asp执行效率高，当访问量较大时，性能没有明显降低
  在HTML文档中文档中嵌入java语言就得到jsp文档，jsp文档的文件扩展名为.jsp
例11.2  显示当前日期时间的jsp文档

4.基于JSP的Web应用结构
  处理jsp文档的是JSP引擎（JSPContainer）.JSP引擎的作用是，编译并执行嵌入HTML文档的JAVA语句。将执行结果动态生成HTML文档
  JSP文档的执行过程如下：
      1.客户端发送today.jsp页面请求给指定Web服务器
      2.web服务器接收请求，将搜索到的today.jsp交由JSP引擎处理
      3.JSP引擎编译并执行JSP文档中嵌入的java语句，动态创建today.html文档，将运行结果包含其中，再将today.html返回给web服务器
      4.web服务器再将today.html返回给客户端
      5.客户端浏览器解释执行HTML文档
  JSP引擎支持对数据库的操作。此时，除了web服务器，还 需要数据库服务器。从结构上看，存在多对客户-服务器关系，浏览器与web服务器是实现web应用的一对客户-服务器关系；而在web服务器上运行的jsp引擎，执行jdbc api对数据库进行操作时，是以数据库客户端身份连接数据库服务器的，它们之间是实现数据库应用的一对客户-服务器关系，因此这种结构通常称为三层浏览器-服务器结构

11.3.2 运行JSP
1.Tomcat
  构建JSP运行环境，最基本配置要有Web服务器和JSP引擎。Tomcat是能够在Apache服务器上运行的一种JSP引擎。
  虚拟目录
2.eclipse运行jsp
 
端口不可用，改server.xml文件的-1为8000，charset=UTF(GBK)  Pagecoding=UTF-8





































